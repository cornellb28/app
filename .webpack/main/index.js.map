{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AChEA,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,YAAY,iEAA8B;;AAE1C,YAAY,mBAAO,CAAC,uFAAO;;AAE3B,UAAU,qDAAuB;;AAEjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA,UAAU,+HAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,oBAAoB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qBAAqB;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,IAAI,aAAa;;;AAGjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;;;;;;;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,qHAAgC;AAChC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;;AAEA;AACA,KAAK,GAAG;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;;AAGA;AACA;AACA,EAAE,aAAa;AACf,EAAE,aAAa;AACf;AACA;;AAEA,kBAAkB,SAAS;AAC3B,6BAA6B;;AAE7B;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;AClMA;AACA;AACA;AACA;AACA;AACA,EAAE,sIAAwC;AAC1C,EAAE;AACF,EAAE,gIAAqC;AACvC;;;;;;;;;;ACRA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,gBAAK;;AAEvB,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA;AACA;AACA;;;AAGA,UAAU,+HAAmC;AAC7C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG,GAAG;;AAEN;AACA,uDAAuD,6DAA6D,oCAAoC;AACxJ;AACA;AACA,CAAC,IAAI;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,oBAAoB;AACpB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,mBAAO,CAAC,cAAI;;AAE3B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;;AAE7B;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,mDAAU;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,kBAAM;;AAE/B;;AAEA,SAAS,mBAAO,CAAC,cAAI,GAAG;;;AAGxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;;;AAGF;AACA,0CAA0C,EAAE;AAC5C,EAAE;AACF;AACA;;AAEA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,sBAAsB;;AAEtB,WAAW;;AAEX,eAAe;;AAEf,YAAY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D;;AAE/D;AACA;AACA,MAAM;;;AAGN;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA,IAAI;;;AAGJ;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,sBAAsB;;AAEtB,WAAW;;AAEX,eAAe;;AAEf,YAAY;;AAEZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpSA,eAAe;AACf,eAAe;AACf,eAAe;AACf,cAAc;AACd,YAAY;AACZ,iBAAiB;AACjB,uBAAuB;;AAEvB;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,cAAI;;AAErB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,gBAAgB,mBAAO,CAAC,0EAAW;;AAEnC,iBAAiB,oDAA0B;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA,uCAAuC;AACvC,YAAY,gCAAgC;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,MAAM;AACN;AACA;AACA,sCAAsC;AACtC;AACA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C;;AAE/C;AACA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,wDAAa;;AAE9B,gBAAgB,mBAAO,CAAC,0EAAW;;AAEnC;;AAEA,eAAe,mBAAO,CAAC,qDAAU;;AAEjC,SAAS,0DAA8B;;AAEvC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B,iBAAiB,oDAA0B;;AAE3C,eAAe,mBAAO,CAAC,8CAAW;;AAElC,aAAa,mBAAO,CAAC,kDAAa;;AAElC;AACA;;AAEA,eAAe,mBAAO,CAAC,qDAAU;;AAEjC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;;AAEA,WAAW,mBAAO,CAAC,yCAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;;AAE7B,qCAAqC,8BAA8B,sBAAsB;AACzF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,yBAAyB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAA8C,6BAA6B;;AAE3G;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,eAAe;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;;;AAGA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA,kCAAkC;AAClC;AACA,GAAG;AACH;AACA;AACA,IAAI;;AAEJ,iCAAiC;;;AAGjC;AACA;AACA,0FAA0F;AAC1F;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ,mCAAmC;;AAEnC,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;;;AAGA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA,+CAA+C;AAC/C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA,yDAAyD;;AAEzD;;AAEA;AACA,4BAA4B;;AAE5B;;AAEA,kBAAkB,SAAS;AAC3B;AACA,oDAAoD;;AAEpD;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,uEAAuE;;AAEvE;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,yEAAyE;;AAEzE;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxrBA,eAAe,mBAAO,CAAC,8DAAgB;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,2BAA2B;AAC/E;;AAEA;AACA,8DAA8D,0BAA0B;AACxF,EAAE;AACF;AACA,wCAAwC,GAAG,IAAI;;;AAG/C;AACA;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,+BAA+B;AAC/B,uCAAuC,GAAG;AAC1C,YAAY,GAAG,yBAAyB;AACxC;AACA;;AAEA,8BAA8B;AAC9B,cAAc,GAAG;AACjB;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,KAAK;AAC1B,wBAAwB;;AAExB;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC,8BAA8B,eAAe;AAC7C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,UAAU,EAAE;AACZ,6BAA6B;AAC7B,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA,cAAc,KAAK,QAAQ,EAAE,IAAI,EAAE;AACnC;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,MAAM;AACN;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,YAAY;AAClC;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACtLA;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;ACLA,4DAA4D;AAC5D,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,6EAAe;;AAEpC;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,kFAAiB;;AAExC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,sBAAsB;;AAEtB,2BAA2B;AAC3B;AACA;;AAEA,2CAA2C,IAAI,iBAAiB;AAChE;;AAEA,iDAAiD,cAAc;;AAE/D;AACA;AACA;AACA,CAAC,IAAI,GAAG;;;AAGR,kCAAkC,aAAa;;AAE/C,2CAA2C;;AAE3C;;AAEA,yCAAyC;;AAEzC,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,GAAG;AACH,KAAK,IAAI;AACT,KAAK,GAAG;AACR,KAAK,KAAK;AACV,KAAK,IAAI,IAAI,EAAE;AACf,KAAK,IAAI,EAAE,IAAI;AACf;AACA;AACA,KAAK,IAAI,OAAO,IAAI;AACpB,KAAK,EAAE,OAAO,EAAE;;;AAGhB;;AAEA,0CAA0C;AAC1C,+BAA+B;AAC/B;;AAEA,6BAA6B,QAAQ,MAAM;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,6EAA6E;;AAE7E,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;;AAEA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;;AAGN,wBAAwB;;AAExB;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,iDAAiD;AACrE;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,oEAAoE,oBAAoB;AACxF;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;;AAEA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;;AAEA;AACA,UAAU;;;AAGV;AACA;AACA,4EAA4E;;AAE5E;AACA,oEAAoE;;AAEpE;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;;;AAGd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,sCAAsC,IAAI;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,+CAA+C;AACtE,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;;AAGA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;AAGZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;;AAGA,sCAAsC,IAAI;AAC1C;AACA;AACA,0CAA0C;;AAE1C,kCAAkC,EAAE,EAAE,KAAK;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;AAGA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;AACA,MAAM;AACN;;;AAGA,8DAA8D;AAC9D;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,aAAa;AAClB;;AAEA,6BAA6B;;AAE7B;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA,MAAM;;;AAGN;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA,0CAA0C;;AAE1C;;AAEA,+BAA+B,QAAQ;AACvC;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;AC/3BA;AACA;;AAEA,SAAS,mBAAO,CAAC,wDAAa;;AAE9B,gBAAgB,mBAAO,CAAC,0EAAW;;AAEnC;;AAEA,WAAW,0EAAyB;;AAEpC,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B,iBAAiB,oDAA0B;;AAE3C,aAAa,mBAAO,CAAC,kDAAa;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,kEAAkE;AAClE;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA,kCAAkC;AAClC;AACA,GAAG;AACH;AACA;AACA,IAAI;;AAEJ,iCAAiC;;;AAGjC;AACA;AACA,sFAAsF;AACtF;;AAEA;AACA,gDAAgD;;;AAGhD,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;;AAEnC,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;;AAGN;AACA,IAAI;AACJ;;;AAGA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA,wEAAwE;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;;AAGA,wBAAwB;AACxB;;AAEA;AACA;AACA,yDAAyD;;AAEzD;;AAEA;AACA,kCAAkC;;AAElC;;AAEA,kBAAkB,SAAS;AAC3B;AACA,oDAAoD;;AAEpD;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uEAAuE;;AAEvE;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,yEAAyE;;AAEzE;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC;;AAErC;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;AC1aA,aAAa,mBAAO,CAAC,+CAAQ;;AAE7B;;AAEA,WAAW,mBAAO,CAAC,yCAAM;;AAEzB;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,kBAAkB,YAAY;;AAE9B;AACA;;;;;;;;;;ACvDA;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;;;AAGA;AACA;AACA,EAAE;AACF;AACA,EAAE,gHAAiD;AACnD;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5BA,WAAW,mBAAO,CAAC,cAAI;;AAEvB,uBAAuB,mBAAO,CAAC,2EAAsB;;AAErD,kBAAkB,mBAAO,CAAC,iEAAiB;;AAE3C,gBAAgB,mBAAO,CAAC,6DAAe;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,qBAAqB;AACrB,mBAAmB;;AAEnB;AACA;AACA,0BAA0B;;AAE1B,mCAAmC;;AAEnC,mCAAmC;AACnC;;AAEA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA,GAAG,GAAG;;AAEN,mBAAmB;;AAEnB,4CAA4C;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG,IAAI;AACP;AACA,eAAe;;AAEf;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;;AAEA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,mDAAmD;AACtF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mIAAmI;;AAEnI;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,gCAAgC,6CAA6C;AAC7E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;AAGA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,6BAA6B;AAC7B,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,6BAA6B;AAC7B,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,6BAA6B;AAC7B,OAAO;AACP,KAAK;AACL;AACA;;;;;;;;;;;ACxfa;;AAEb,aAAa,wFAA8B,EAAE;AAC7C;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,WAAW,sCAAsC;;;AAGjE;AACA;AACA;AACA,iGAAiG;;AAEjG,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA,4BAA4B;;AAE5B,kBAAkB,yBAAyB,4CAA4C;;;AAGvF;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA,sDAAsD;;AAEtD;;AAEA,uBAAuB,WAAW;AAClC;;AAEA,yBAAyB,WAAW;AACpC;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA,4BAA4B;;AAE5B;AACA,mDAAmD,wCAAwC;AAC3F;AACA,6DAA6D,4BAA4B,aAAa;AACtG,IAAI;;AAEJ,gDAAgD;;;AAGhD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;;AAE3C;AACA;;AAEA,SAAS,UAAU;;AAEnB;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC;;AAExC;;AAEA,4BAA4B;;AAE5B,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;;AAEA;AACA;AACA;AACA,0IAA0I;AAC1I,UAAU;AACV;AACA;AACA;;AAEA,0BAA0B,SAAS,qCAAqC;;;AAGxE;AACA;AACA,UAAU,mCAAmC;;AAE7C;AACA,MAAM;AACN;AACA;;AAEA,sBAAsB,UAAU;AAChC,MAAM;AACN;;AAEA;AACA,GAAG;;;AAGH;AACA,yBAAyB;;AAEzB,+FAA+F;;AAE/F;AACA;;AAEA;AACA;;AAEA;AACA,mGAAmG;AACnG;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kEAAkE;;AAElE;AACA;AACA,IAAI;;;AAGJ,kBAAkB,oBAAoB;AACtC;AACA,kDAAkD;AAClD;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;AACA,2CAA2C;;AAE3C,4FAA4F;AAC5F;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iCAAiC;;AAEjC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,0BAA0B;;AAE1B;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B,4BAA4B;AAC5B,UAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;;AAEA;AACA;AACA,MAAM;AACN,mCAAmC;;AAEnC,qCAAqC;AACrC,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE;;AAEtE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR,qCAAqC;;AAErC,uCAAuC;AACvC;AACA,MAAM,MAAM;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH,yCAAyC;;AAEzC;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,gBAAgB;AACzC,+DAA+D;;AAE/D;;AAEA,qBAAqB;AACrB,MAAM;AACN;AACA;AACA;AACA,oBAAoB;AACpB,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,MAAM,6HAA6H;;;AAGnI;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;;;;;;;;;;;ACrjBa,CAAC;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,8GAAwB;AAC7C,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,wGAAqB;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,wGAAqB;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,aAAa,sIAAqC,CAAC,mBAAO,CAAC,gHAAyB;AACpF;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sIAAqC,CAAC,mBAAO,CAAC,gHAAyB;AACpF,KAAK;AACL;AACA,aAAa,mBAAO,CAAC,0HAA8B;AACnD,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,wGAAqB;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,wGAAqB;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,aAAa,sIAAqC,CAAC,mBAAO,CAAC,kHAA0B;AACrF,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;ACtLa,CAAC;AACd;;AAEA,eAAe,mBAAO,CAAC,yFAAY,GAAG,mBAAO,CAAC,mFAAS,GAAG,mBAAO,CAAC,mFAAS,GAAG,mBAAO,CAAC,iFAAQ,GAAG,mBAAO,CAAC,6FAAc,GAAG,mBAAO,CAAC,2FAAa,GAAG,mBAAO,CAAC,+GAAuB,GAAG,mBAAO,CAAC,6FAAc,GAAG,mBAAO,CAAC,2FAAa,IAAI;;AAEtO,gBAAgB,oBAAoB;AACpC;;AAEA;AACA;;;;;;;;;;;ACTa;;AAEb,aAAa,wFAA8B,EAAE;;;AAG7C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,kEAAkE;AAClE,uBAAuB;;AAEvB,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA,oBAAoB,2EAAuC;;AAE3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD;AAChD;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC,sCAAsC;AACtC;;AAEA,kDAAkD;AAClD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qDAAqD;AACrD;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sFAAsF,uEAAuE;AAC7J;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7Ma;;AAEb,aAAa,wFAA8B,EAAE;AAC7C;;;AAGA,aAAa;;AAEb;AACA,gFAAgF;;AAEhF;;AAEA;AACA;;AAEA,oBAAoB,SAAS;;AAE7B;AACA;;AAEA,4DAA4D;;AAE5D;;AAEA,kBAAkB,+BAA+B;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;;AAElC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACpEa,CAAC;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uNAAuN,iEAAiE,EAAE;AAC1R,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2JAA2J,iEAAiE,EAAE;AAC9N,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yLAAyL,iEAAiE,EAAE;AAC5P,GAAG;AACH;AACA;AACA,uNAAuN,iEAAiE,EAAE;AAC1R,GAAG;AACH;AACA;AACA,uNAAuN,gEAAgE,EAAE;AACzR,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjca,CAAC;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnJa;;AAEb,aAAa,wFAA8B,EAAE;AAC7C;;;AAGA,eAAe;;AAEf;;AAEA;AACA;AACA,wCAAwC;;AAExC;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C;;;AAG/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,oBAAoB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,+DAA+D,4BAA4B;AAC3F;;;AAGA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,oBAAoB,6BAA6B;;AAEjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6BAA6B;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,8BAA8B,iBAAiB;AAC/C;;AAEA,oBAAoB,gBAAgB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA,sDAAsD;;AAEtD;AACA;;;;;;;;;;;AC/Ka;;AAEb,aAAa,wFAA8B,EAAE;;;AAG7C,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,GAAG;;AAEH,cAAc;AACd,cAAc;AACd;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uCAAuC;;AAElD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,IAAI;;;AAGJ,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI;;;AAGJ,SAAS,gBAAgB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,uEAAuE,4BAA4B;AACnG,qEAAqE;;;AAGrE,aAAa;AACb,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,oBAAoB,6BAA6B;;AAEjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6BAA6B;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,sBAAsB;;AAEtB,8BAA8B,iBAAiB;AAC/C;;AAEA,oBAAoB,gBAAgB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,0EAA0E;;AAE1E;AACA;;;;;;;;;;;AChSa;;AAEb,aAAa,wFAA8B,EAAE;AAC7C;;;AAGA,YAAY;AACZ,qBAAqB,WAAW;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;;AAErC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,GAAG;AACH;;AAEA,4CAA4C;;;AAG5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,SAAS;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD,IAAI;AACJ;AACA,0DAA0D;;AAE1D,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,gBAAgB;;AAEhB;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;;AAEnC;AACA;;AAEA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD,IAAI;AACJ;AACA,0DAA0D;;AAE1D,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ra;;AAEb;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AC/Ca;;AAEb,aAAa,wFAA8B;;AAE3C,kBAAkB,mBAAO,CAAC,2FAAgB;AAC1C,4BAA4B;AAC5B;;;AAGA,wBAAwB;;AAExB;AACA,mCAAmC;;AAEnC;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;;;AAGH;AACA,mCAAmC;;AAEnC;;AAEA;AACA,0CAA0C,mBAAO,CAAC,wFAAc,GAAG;AACnE;;AAEA,mDAAmD;;;AAGnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yEAAyE;AACzE;;AAEA;AACA,kEAAkE;;AAElE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,EAAE;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA,qCAAqC;;AAErC,gBAAgB,mBAAO,CAAC,iFAAW,kBAAkB;;;AAGrD;AACA,iEAAiE;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;;AAEA;AACA,kBAAkB,mBAAO,CAAC,sBAAQ;AAClC,EAAE;;AAEF;AACA;AACA,EAAE;AACF;AACA;AACA,+GAA+G;AAC/G;AACA;;AAEA,IAAI,KAAe,EAAE;;;;;;;;;;;AC9JR;;AAEb,aAAa,wFAA8B,EAAE;AAC7C;;;AAGA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;;;AAGL;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,wBAAwB;AACxB,gCAAgC;AAChC,yCAAyC;AACzC,gCAAgC;;;;;;;;;;AC/LhC;;AAEA,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACnEA;;AAEA,gBAAgB,mBAAO,CAAC,yDAAW;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACtEA,WAAW,mBAAO,CAAC,cAAI;;AAEvB,wBAAwB,mBAAO,CAAC,yEAAmB;;AAEnD,uBAAuB,mBAAO,CAAC,uEAAkB;;AAEjD,uBAAuB,mBAAO,CAAC,uEAAkB;;AAEjD,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnTA,cAAc,mBAAO,CAAC,gFAAY;;AAElC,uBAAuB,mBAAO,CAAC,uEAAkB;;AAEjD;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA,yBAAyB;AACzB;AACA;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;;;;;;;;;;ACzOA,aAAa,mBAAO,CAAC,+CAAQ;;AAE7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzCA;AACa;;AAEb,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,WAAW;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFwC;AACA;AACA;AACA;AACE;AACQ;AACE;AACE;;;;;;;;;;;;;;;;;;ACP1B;;AAE5B;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,SAAS,wDAAiB;AAC1B;;AAEA,iEAAe,GAAG;;;;;;;;;;;;;;;ACZlB,iEAAe,sCAAsC;;;;;;;;;;;;;;;;ACAhB;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;;AAErB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,KAAK;;;;;;;;;;;;;;;AClCpB,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;;;;ACAxG;AAC5B,uCAAuC;;AAEvC;AACe;AACf;AACA,IAAI,4DAAqB;AACzB;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACX4B;;AAE5B;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,SAAS,wDAAiB;AAC1B;;AAEA,iEAAe,IAAI;;;;;;;;;;;;;;;;ACZkB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA,4gBAA4gB;AAC5gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;;AC5BG;AACY,CAAC;AACxC;AACA;AACA;;AAEA;;AAEA,eAAe;;;AAGf;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;;AAEA;AACA,wDAAwD,+CAAG;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA,wEAAwE;AACxE;;AAEA,4EAA4E;;AAE5E,gEAAgE;;AAEhE;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,uBAAuB;;AAEvB,oCAAoC;;AAEpC,8BAA8B;;AAE9B,kCAAkC;;AAElC,4BAA4B;;AAE5B,kBAAkB,OAAO;AACzB;AACA;;AAEA,gBAAgB,yDAAS;AACzB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;AC9FU;AACA;AAC3B,WAAW,mDAAG,aAAa,+CAAG;AAC9B,iEAAe,EAAE;;;;;;;;;;;;;;;;;;;ACHsB;AACR;;AAE/B;AACA,2CAA2C;;AAE3C;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA;;AAEO;AACA;AACP,6BAAe,oCAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qDAAK;AACvB;;AAEA;AACA;AACA,MAAM;AACN;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA;;AAEA,WAAW,yDAAS;AACpB,IAAI;;;AAGJ;AACA,8BAA8B;AAC9B,IAAI,eAAe;;;AAGnB;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/D2B;AACY;;AAEvC;AACA;AACA,iDAAiD,+CAAG,KAAK;;AAEzD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;;;ACvBU;AACE;AAC7B,WAAW,mDAAG,aAAa,gDAAI;AAC/B,iEAAe,EAAE;;;;;;;;;;;;;;;;ACHc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;ACNc;;AAErC;AACA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,OAAO;;;;;;;;;;ACVtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjCA,6DAAyB;AACzB,8EAA4B;AAC5B,4GAA+B;AAE/B,6FAAoC;AAEpC,mDAAmD;AACnD,MAAM,cAAc,GAAG,KAAK,EAAE,IAAY,EAAE,EAAE;IAC5C,MAAM,iBAAiB,GAAG,CAAC,IAAY,EAAE,EAAE;QACzC,OAAO,IAAI,OAAO,CAAW,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC/C,eAAI,EAAC,GAAG,IAAI,iBAAiB,EAAE,CAAC,GAAU,EAAE,KAAe,EAAE,EAAE;gBAC7D,OAAO,CAAC,KAAK,CAAC,CAAC;YACjB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACF,MAAM,MAAM,GAAa,MAAM,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACvD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,oCAAoC;AAC7B,MAAM,WAAW,GAAG,CAAC,SAAmB,EAAW,EAAE;IAC1D,IAAI,KAAK,GAAY,KAAK,CAAC;IAC3B,KAAK,IAAI,IAAI,IAAI,SAAS,EAAE;QAC1B,IAAI,WAAW,GAAG,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;QAC5E,IAAI,WAAW,KAAK,KAAK;YAAE,OAAO;QAClC,KAAK,GAAG,WAAW,CAAC;KACrB;IACD,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AARW,mBAAW,eAQtB;AAEF,uCAAuC;AACvC,MAAM,UAAU,GAAG,KAAK,EAAE,IAAY,EAAE,EAAE;IACxC,MAAM,QAAQ,GAAG,MAAM,kBAAO,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;IAC5D,OAAO,QAAQ,CAAC;AAClB,CAAC,CAAC;AAEF,4CAA4C;AAC5C,SAAS,eAAe,CACtB,IAAS,EACT,QAAgB,EAChB,QAAgB;IAEhB,OAAO;QACL,EAAE,EAAE,aAAM,GAAE;QACZ,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ;QACtC,QAAQ,EAAE,QAAQ;QAClB,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;QACnC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;QACtC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;QAC7B,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE;QACrD,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;QAC5C,YAAY,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE;QACxD,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE;QAClD,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;QAC3C,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;QAChC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,eAAe;QAChD,OAAO,EAAE;YACP,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,iBAAiB;SAClE;KACF,CAAC;AACJ,CAAC;AAED,kCAAkC;AAC3B,MAAM,WAAW,GAAG,KAAK,EAAE,GAAW,EAAE,EAAE;IAC/C,MAAM,UAAU,GAAG,MAAM,cAAc,CAAC,GAAG,CAAC,CAAC;IAC7C,IAAI,QAAQ,GAAgB,EAAE,CAAC;IAE/B,KAAK,IAAI,QAAQ,IAAI,UAAU,EAAE;QAC/B,MAAM,KAAK,GAAG,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACpC,MAAM,gBAAgB,GAAG,GAAG,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAC3D,MAAM,SAAS,GAAG,MAAM,UAAU,CAAC,QAAQ,CAAC,CAAC;QAC7C,MAAM,aAAa,GAAG,eAAe,CACnC,SAAS,EACT,QAAQ,EACR,gBAAgB,CACjB,CAAC;QACF,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;KAC9B;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC,CAAC;AAhBW,mBAAW,eAgBtB;AAEF,uEAAuE;AACvE,UAAU;AACV,0CAA0C;AAC1C,2DAA2D;AAC3D,yBAAyB;AACzB,+BAA+B;AAC/B,gDAAgD;AAChD,yCAAyC;AAEzC,mCAAmC;AACnC,0BAA0B;AAC1B,iBAAiB;AACjB,oCAAoC;AACpC,sBAAsB;AACtB,qCAAqC;AACrC,MAAM;AACN,KAAK;AAEL,MAAM,CAAC,OAAO,GAAG;IACf,WAAW,EAAX,mBAAW;IACX,WAAW,EAAX,mBAAW;CACZ,CAAC;AAEF,8DAA8D;;;;;;;;;;;;ACxG9D;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNA,mEAA+D;AAI/D,gFAAwD;AAExD,MAAM,MAAM,GAAG,qBAAqB,CAAC;AAOrC,8EAA8E;AAC9E,IAAI,mBAAO,CAAC,oFAA2B,CAAC,EAAE;IACxC,qCAAqC;IACrC,cAAG,CAAC,IAAI,EAAE,CAAC;CACZ;AAED,MAAM,YAAY,GAAG,GAAS,EAAE;IAC9B,6BAA6B;IAC7B,MAAM,UAAU,GAAG,IAAI,wBAAa,CAAC;QACnC,MAAM,EAAE,GAAG;QACX,KAAK,EAAE,GAAG;QACV,cAAc,EAAE;YACd,gBAAgB,EAAE,IAAI;YACtB,OAAO,EAAE,SAAiC;SAC3C;KACF,CAAC,CAAC;IAEH,sCAAsC;IACtC,UAAU,CAAC,OAAO,CAAC,mCAAyB,CAAC,CAAC;IAE9C,qBAAqB;IACrB,UAAU,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC;AACxC,CAAC,CAAC;AAEF,wDAAwD;AACxD,yDAAyD;AACzD,sDAAsD;AACtD,cAAG,CAAC,EAAE,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;AAE9B,wEAAwE;AACxE,0EAA0E;AAC1E,2BAA2B;AAC3B,cAAG,CAAC,EAAE,CAAC,mBAAmB,EAAE,GAAG,EAAE;IAC/B,IAAI,OAAO,CAAC,QAAQ,KAAK,QAAQ,EAAE;QACjC,cAAG,CAAC,IAAI,EAAE,CAAC;KACZ;AACH,CAAC,CAAC,CAAC;AAEH,cAAG,CAAC,EAAE,CAAC,UAAU,EAAE,GAAG,EAAE;IACtB,gEAAgE;IAChE,4DAA4D;IAC5D,IAAI,wBAAa,CAAC,aAAa,EAAE,CAAC,MAAM,KAAK,CAAC,EAAE;QAC9C,YAAY,EAAE,CAAC;KAChB;AACH,CAAC,CAAC,CAAC;AAEH,4EAA4E;AAC5E,sEAAsE;AACtE,kBAAO,CAAC,MAAM,CAAC,cAAc,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE;IACnD,+CAA+C;IAC/C,MAAM,YAAY,GAAG,MAAM,iBAAM,CAAC,cAAc,CAAC;QAC/C,UAAU,EAAE,CAAC,eAAe,EAAE,iBAAiB,EAAE,UAAU,CAAC;KAC7D,CAAC,CAAC;IAEH,wDAAwD;IACxD,IAAI,YAAY,CAAC,QAAQ;QAAE,OAAO;IAElC,uDAAuD;IACvD,MAAM,YAAY,GAAyB,YAAY,EAAE,SAAS,CAAC;IAEnE,4BAA4B;IAC5B,IAAI,YAAY,IAAI,uBAAW,EAAC,YAAY,CAAC,EAAE;QAC7C,kDAAkD;QAClD,kEAAkE;QAClE,MAAM,CAAC,UAAU,CAAC,GAAG,YAAY,CAAC;QAClC,MAAM,SAAS,GAAG,MAAM,uBAAW,EAAC,UAAU,CAAC,CAAC;QAChD,OAAO,SAAS,CAAC;KAClB;IACD,4BAA4B;AAC9B,CAAC,CAAC,CAAC;AAEH,0FAA0F;AAC1F,0FAA0F","sources":["webpack://mb-app/./node_modules/balanced-match/index.js","webpack://mb-app/./node_modules/electron-squirrel-startup/index.js","webpack://mb-app/./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js","webpack://mb-app/./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js","webpack://mb-app/./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js","webpack://mb-app/./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js","webpack://mb-app/./node_modules/electron-squirrel-startup/node_modules/ms/index.js","webpack://mb-app/./node_modules/fs.realpath/index.js","webpack://mb-app/./node_modules/fs.realpath/old.js","webpack://mb-app/./node_modules/glob/common.js","webpack://mb-app/./node_modules/glob/glob.js","webpack://mb-app/./node_modules/glob/node_modules/brace-expansion/index.js","webpack://mb-app/./node_modules/glob/node_modules/minimatch/lib/path.js","webpack://mb-app/./node_modules/glob/node_modules/minimatch/minimatch.js","webpack://mb-app/./node_modules/glob/sync.js","webpack://mb-app/./node_modules/inflight/inflight.js","webpack://mb-app/./node_modules/inherits/inherits.js","webpack://mb-app/./node_modules/inherits/inherits_browser.js","webpack://mb-app/./node_modules/node-id3/index.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/dbcs-codec.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/dbcs-data.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/index.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/internal.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/sbcs-codec.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/sbcs-data-generated.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/sbcs-data.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/utf16.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/utf32.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/encodings/utf7.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/lib/bom-handling.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/lib/index.js","webpack://mb-app/./node_modules/node-id3/node_modules/iconv-lite/lib/streams.js","webpack://mb-app/./node_modules/node-id3/src/ID3Definitions.js","webpack://mb-app/./node_modules/node-id3/src/ID3FrameBuilder.js","webpack://mb-app/./node_modules/node-id3/src/ID3FrameReader.js","webpack://mb-app/./node_modules/node-id3/src/ID3Frames.js","webpack://mb-app/./node_modules/node-id3/src/ID3Util.js","webpack://mb-app/./node_modules/once/once.js","webpack://mb-app/./node_modules/safer-buffer/safer.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/index.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/md5.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/nil.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/parse.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/regex.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/rng.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/sha1.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/stringify.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/v1.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/v3.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/v35.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/v4.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/v5.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/validate.js","webpack://mb-app/./node_modules/uuid/dist/esm-node/version.js","webpack://mb-app/./node_modules/wrappy/wrappy.js","webpack://mb-app/./src/utils/index.ts","webpack://mb-app/external node-commonjs \"assert\"","webpack://mb-app/external node-commonjs \"buffer\"","webpack://mb-app/external node-commonjs \"child_process\"","webpack://mb-app/external node-commonjs \"crypto\"","webpack://mb-app/external node-commonjs \"electron\"","webpack://mb-app/external node-commonjs \"events\"","webpack://mb-app/external node-commonjs \"fs\"","webpack://mb-app/external node-commonjs \"net\"","webpack://mb-app/external node-commonjs \"path\"","webpack://mb-app/external node-commonjs \"stream\"","webpack://mb-app/external node-commonjs \"string_decoder\"","webpack://mb-app/external node-commonjs \"tty\"","webpack://mb-app/external node-commonjs \"util\"","webpack://mb-app/webpack/bootstrap","webpack://mb-app/webpack/runtime/compat get default export","webpack://mb-app/webpack/runtime/define property getters","webpack://mb-app/webpack/runtime/hasOwnProperty shorthand","webpack://mb-app/webpack/runtime/make namespace object","webpack://mb-app/./dev/main.ts"],"sourcesContent":["'use strict';\n\nmodule.exports = balanced;\n\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n  var r = range(a, b, str);\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\n\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi];\n    }\n\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [begs.pop(), bi];\n      } else {\n        beg = begs.pop();\n\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [left, right];\n    }\n  }\n\n  return result;\n}","var path = require('path');\n\nvar spawn = require('child_process').spawn;\n\nvar debug = require('debug')('electron-squirrel-startup');\n\nvar app = require('electron').app;\n\nvar run = function (args, done) {\n  var updateExe = path.resolve(path.dirname(process.execPath), '..', 'Update.exe');\n  debug('Spawning `%s` with args `%s`', updateExe, args);\n  spawn(updateExe, args, {\n    detached: true\n  }).on('close', done);\n};\n\nvar check = function () {\n  if (process.platform === 'win32') {\n    var cmd = process.argv[1];\n    debug('processing squirrel command `%s`', cmd);\n    var target = path.basename(process.execPath);\n\n    if (cmd === '--squirrel-install' || cmd === '--squirrel-updated') {\n      run(['--createShortcut=' + target + ''], app.quit);\n      return true;\n    }\n\n    if (cmd === '--squirrel-uninstall') {\n      run(['--removeShortcut=' + target + ''], app.quit);\n      return true;\n    }\n\n    if (cmd === '--squirrel-obsolete') {\n      app.quit();\n      return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = check();","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n/**\n * Colors.\n */\n\nexports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  } // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?\n  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\n\nexports.formatters.j = function (v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n  if (!useColors) return;\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit'); // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function (match) {\n    if ('%%' === match) return;\n    index++;\n\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n  args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch (e) {}\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  var r;\n\n  try {\n    r = exports.storage.debug;\n  } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\n\nexports.enable(load());\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}","/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0,\n      i;\n\n  for (i in namespace) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\n\nfunction createDebug(namespace) {\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n    var self = debug; // set `diff` timestamp\n\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr; // turn the `arguments` into a proper Array\n\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    } // apply any `formatters` transformations\n\n\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`\n\n        args.splice(index, 1);\n        index--;\n      }\n\n      return match;\n    }); // apply env-specific formatting (colors, etc.)\n\n    exports.formatArgs.call(self, args);\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace); // env-specific initialization logic for debug instances\n\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n  exports.names = [];\n  exports.skips = [];\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n\n    namespaces = split[i].replace(/\\*/g, '.*?');\n\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n/**\n * Disable debug output.\n *\n * @api public\n */\n\n\nfunction disable() {\n  exports.enable('');\n}\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\n\nfunction enabled(name) {\n  var i, len;\n\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}","/**\n * Module dependencies.\n */\nvar tty = require('tty');\n\nvar util = require('util');\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n    return k.toUpperCase();\n  }); // coerce string value into JS value\n\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n  obj[prop] = val;\n  return obj;\n}, {});\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();\n}\n\nvar stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);\n}\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\n\nexports.formatters.o = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts).split('\\n').map(function (str) {\n    return str.trim();\n  }).join(' ');\n};\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\n\nexports.formatters.O = function (v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];\n  }\n}\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\n\nfunction load() {\n  return process.env.DEBUG;\n}\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\n\nfunction createWritableStdioStream(fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap'); // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty'; // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n\n      stream = new fs.SyncWriteStream(fd, {\n        autoClose: false\n      });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      }); // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe'; // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  } // For supporting legacy API we put the FD here.\n\n\n  stream.fd = fd;\n  stream._isStdio = true;\n  return stream;\n}\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\n\nfunction init(debug) {\n  debug.inspectOpts = {};\n  var keys = Object.keys(exports.inspectOpts);\n\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\n\nexports.enable(load());","/**\n * Helpers.\n */\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\n\nfunction parse(str) {\n  str = String(str);\n\n  if (str.length > 100) {\n    return;\n  }\n\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\n  if (!match) {\n    return;\n  }\n\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n\n    default:\n      return undefined;\n  }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n\n  return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n}\n/**\n * Pluralization helper.\n */\n\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}","module.exports = realpath;\nrealpath.realpath = realpath;\nrealpath.sync = realpathSync;\nrealpath.realpathSync = realpathSync;\nrealpath.monkeypatch = monkeypatch;\nrealpath.unmonkeypatch = unmonkeypatch;\n\nvar fs = require('fs');\n\nvar origRealpath = fs.realpath;\nvar origRealpathSync = fs.realpathSync;\nvar version = process.version;\nvar ok = /^v[0-5]\\./.test(version);\n\nvar old = require('./old.js');\n\nfunction newError(er) {\n  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');\n}\n\nfunction realpath(p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb);\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache;\n    cache = null;\n  }\n\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb);\n    } else {\n      cb(er, result);\n    }\n  });\n}\n\nfunction realpathSync(p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache);\n  }\n\n  try {\n    return origRealpathSync(p, cache);\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache);\n    } else {\n      throw er;\n    }\n  }\n}\n\nfunction monkeypatch() {\n  fs.realpath = realpath;\n  fs.realpathSync = realpathSync;\n}\n\nfunction unmonkeypatch() {\n  fs.realpath = origRealpath;\n  fs.realpathSync = origRealpathSync;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar pathModule = require('path');\n\nvar isWindows = process.platform === 'win32';\n\nvar fs = require('fs'); // JavaScript implementation of realpath, ported from node pre-v6\n\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n\n  if (DEBUG) {\n    var backtrace = new Error();\n    callback = debugCallback;\n  } else callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation) console.trace(msg);else console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize; // Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\n\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n} // Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\n\n\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {}; // current character position in p\n\n  var pos; // the partial path so far, including a trailing slash if any\n\n  var current; // the partial path without a trailing slash (except when pointing at a root)\n\n  var base; // the partial path scanned in the previous round, with slash\n\n  var previous;\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  } // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n\n\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex; // continue if not a symlink\n\n    if (knownHard[base] || cache && cache[base] === base) {\n      continue;\n    }\n\n    var resolvedLink;\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      } // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n\n\n      var linkTarget = null;\n\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n\n      resolvedLink = pathModule.resolve(previous, linkTarget); // track this, if given a cache.\n\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    } // resolve the link, then start over\n\n\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n  return p;\n};\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  } // make p is absolute\n\n\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {}; // current character position in p\n\n  var pos; // the partial path so far, including a trailing slash if any\n\n  var current; // the partial path without a trailing slash (except when pointing at a root)\n\n  var base; // the partial path scanned in the previous round, with slash\n\n  var previous;\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function (err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  } // walk down the path, swapping out linked pathparts for their real\n  // values\n\n\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    } // find the next part\n\n\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex; // continue if not a symlink\n\n    if (knownHard[base] || cache && cache[base] === base) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err); // if not a symlink, skip to the next path part\n\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    } // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n\n\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n\n    fs.stat(base, function (err) {\n      if (err) return cb(err);\n      fs.readlink(base, function (err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};","exports.setopts = setopts;\nexports.ownProp = ownProp;\nexports.makeAbs = makeAbs;\nexports.finish = finish;\nexports.mark = mark;\nexports.isIgnored = isIgnored;\nexports.childrenIgnored = childrenIgnored;\n\nfunction ownProp(obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field);\n}\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar minimatch = require(\"minimatch\");\n\nvar isAbsolute = require(\"path\").isAbsolute;\n\nvar Minimatch = minimatch.Minimatch;\n\nfunction alphasort(a, b) {\n  return a.localeCompare(b, 'en');\n}\n\nfunction setupIgnores(self, options) {\n  self.ignore = options.ignore || [];\n  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap);\n  }\n} // ignore patterns are always in dot:true mode.\n\n\nfunction ignoreMap(pattern) {\n  var gmatcher = null;\n\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '');\n    gmatcher = new Minimatch(gpattern, {\n      dot: true\n    });\n  }\n\n  return {\n    matcher: new Minimatch(pattern, {\n      dot: true\n    }),\n    gmatcher: gmatcher\n  };\n}\n\nfunction setopts(self, pattern, options) {\n  if (!options) options = {}; // base-matching: just use globstar for that.\n\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\");\n    }\n\n    pattern = \"**/\" + pattern;\n  }\n\n  self.silent = !!options.silent;\n  self.pattern = pattern;\n  self.strict = options.strict !== false;\n  self.realpath = !!options.realpath;\n  self.realpathCache = options.realpathCache || Object.create(null);\n  self.follow = !!options.follow;\n  self.dot = !!options.dot;\n  self.mark = !!options.mark;\n  self.nodir = !!options.nodir;\n  if (self.nodir) self.mark = true;\n  self.sync = !!options.sync;\n  self.nounique = !!options.nounique;\n  self.nonull = !!options.nonull;\n  self.nosort = !!options.nosort;\n  self.nocase = !!options.nocase;\n  self.stat = !!options.stat;\n  self.noprocess = !!options.noprocess;\n  self.absolute = !!options.absolute;\n  self.fs = options.fs || fs;\n  self.maxLength = options.maxLength || Infinity;\n  self.cache = options.cache || Object.create(null);\n  self.statCache = options.statCache || Object.create(null);\n  self.symlinks = options.symlinks || Object.create(null);\n  setupIgnores(self, options);\n  self.changedCwd = false;\n  var cwd = process.cwd();\n  if (!ownProp(options, \"cwd\")) self.cwd = path.resolve(cwd);else {\n    self.cwd = path.resolve(options.cwd);\n    self.changedCwd = self.cwd !== cwd;\n  }\n  self.root = options.root || path.resolve(self.cwd, \"/\");\n  self.root = path.resolve(self.root); // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n  self.nomount = !!options.nomount;\n\n  if (process.platform === \"win32\") {\n    self.root = self.root.replace(/\\\\/g, \"/\");\n    self.cwd = self.cwd.replace(/\\\\/g, \"/\");\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n  } // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n\n\n  options.nonegate = true;\n  options.nocomment = true; // always treat \\ in patterns as escapes, not path separators\n\n  options.allowWindowsEscape = true;\n  self.minimatch = new Minimatch(pattern, options);\n  self.options = self.minimatch.options;\n}\n\nfunction finish(self) {\n  var nou = self.nounique;\n  var all = nou ? [] : Object.create(null);\n\n  for (var i = 0, l = self.matches.length; i < l; i++) {\n    var matches = self.matches[i];\n\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i];\n        if (nou) all.push(literal);else all[literal] = true;\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches);\n      if (nou) all.push.apply(all, m);else m.forEach(function (m) {\n        all[m] = true;\n      });\n    }\n  }\n\n  if (!nou) all = Object.keys(all);\n  if (!self.nosort) all = all.sort(alphasort); // at *some* point we statted all of these\n\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i]);\n    }\n\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !/\\/$/.test(e);\n        var c = self.cache[e] || self.cache[makeAbs(self, e)];\n        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);\n        return notDir;\n      });\n    }\n  }\n\n  if (self.ignore.length) all = all.filter(function (m) {\n    return !isIgnored(self, m);\n  });\n  self.found = all;\n}\n\nfunction mark(self, p) {\n  var abs = makeAbs(self, p);\n  var c = self.cache[abs];\n  var m = p;\n\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c);\n    var slash = p.slice(-1) === '/';\n    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m);\n      self.statCache[mabs] = self.statCache[abs];\n      self.cache[mabs] = self.cache[abs];\n    }\n  }\n\n  return m;\n} // lotta situps...\n\n\nfunction makeAbs(self, f) {\n  var abs = f;\n\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f);\n  } else if (isAbsolute(f) || f === '') {\n    abs = f;\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f);\n  } else {\n    abs = path.resolve(f);\n  }\n\n  if (process.platform === 'win32') abs = abs.replace(/\\\\/g, '/');\n  return abs;\n} // Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\n\n\nfunction isIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}\n\nfunction childrenIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}","// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\nmodule.exports = glob;\n\nvar rp = require('fs.realpath');\n\nvar minimatch = require('minimatch');\n\nvar Minimatch = minimatch.Minimatch;\n\nvar inherits = require('inherits');\n\nvar EE = require('events').EventEmitter;\n\nvar path = require('path');\n\nvar assert = require('assert');\n\nvar isAbsolute = require('path').isAbsolute;\n\nvar globSync = require('./sync.js');\n\nvar common = require('./common.js');\n\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\n\nvar inflight = require('inflight');\n\nvar util = require('util');\n\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\n\nvar once = require('once');\n\nfunction glob(pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {};\n  if (!options) options = {};\n\n  if (options.sync) {\n    if (cb) throw new TypeError('callback provided to sync glob');\n    return globSync(pattern, options);\n  }\n\n  return new Glob(pattern, options, cb);\n}\n\nglob.sync = globSync;\nvar GlobSync = glob.GlobSync = globSync.GlobSync; // old api surface\n\nglob.glob = glob;\n\nfunction extend(origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin;\n  }\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n\n  return origin;\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_);\n  options.noprocess = true;\n  var g = new Glob(pattern, options);\n  var set = g.minimatch.set;\n  if (!pattern) return false;\n  if (set.length > 1) return true;\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string') return true;\n  }\n\n  return false;\n};\n\nglob.Glob = Glob;\ninherits(Glob, EE);\n\nfunction Glob(pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.sync) {\n    if (cb) throw new TypeError('callback provided to sync glob');\n    return new GlobSync(pattern, options);\n  }\n\n  if (!(this instanceof Glob)) return new Glob(pattern, options, cb);\n  setopts(this, pattern, options);\n  this._didRealPath = false; // process each pattern in the minimatch set\n\n  var n = this.minimatch.set.length; // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n\n  this.matches = new Array(n);\n\n  if (typeof cb === 'function') {\n    cb = once(cb);\n    this.on('error', cb);\n    this.on('end', function (matches) {\n      cb(null, matches);\n    });\n  }\n\n  var self = this;\n  this._processing = 0;\n  this._emitQueue = [];\n  this._processQueue = [];\n  this.paused = false;\n  if (this.noprocess) return this;\n  if (n === 0) return done();\n  var sync = true;\n\n  for (var i = 0; i < n; i++) {\n    this._process(this.minimatch.set[i], i, false, done);\n  }\n\n  sync = false;\n\n  function done() {\n    --self._processing;\n\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish();\n        });\n      } else {\n        self._finish();\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob);\n  if (this.aborted) return;\n  if (this.realpath && !this._didRealpath) return this._realpath();\n  common.finish(this);\n  this.emit('end', this.found);\n};\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath) return;\n  this._didRealpath = true;\n  var n = this.matches.length;\n  if (n === 0) return this._finish();\n  var self = this;\n\n  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);\n\n  function next() {\n    if (--n === 0) self._finish();\n  }\n};\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index];\n  if (!matchset) return cb();\n  var found = Object.keys(matchset);\n  var self = this;\n  var n = found.length;\n  if (n === 0) return cb();\n  var set = this.matches[index] = Object.create(null);\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p);\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set;\n        cb();\n      }\n    });\n  });\n};\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p);\n};\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f);\n};\n\nGlob.prototype.abort = function () {\n  this.aborted = true;\n  this.emit('abort');\n};\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true;\n    this.emit('pause');\n  }\n};\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume');\n    this.paused = false;\n\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0);\n\n      this._emitQueue.length = 0;\n\n      for (var i = 0; i < eq.length; i++) {\n        var e = eq[i];\n\n        this._emitMatch(e[0], e[1]);\n      }\n    }\n\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0);\n\n      this._processQueue.length = 0;\n\n      for (var i = 0; i < pq.length; i++) {\n        var p = pq[i];\n        this._processing--;\n\n        this._process(p[0], p[1], p[2], p[3]);\n      }\n    }\n  }\n};\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob);\n  assert(typeof cb === 'function');\n  if (this.aborted) return;\n  this._processing++;\n\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb]);\n\n    return;\n  } //console.error('PROCESS %d', this._processing, pattern)\n  // Get the first [n] parts of pattern that are all strings.\n\n\n  var n = 0;\n\n  while (typeof pattern[n] === 'string') {\n    n++;\n  } // now n is the index of the first one that is *not* a string.\n  // see if there's anything else\n\n\n  var prefix;\n\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb);\n\n      return;\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break;\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break;\n  }\n\n  var remain = pattern.slice(n); // get the list of entries.\n\n  var read;\n  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.map(function (p) {\n    return typeof p === 'string' ? p : '[*]';\n  }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n    read = prefix;\n  } else read = prefix;\n\n  var abs = this._makeAbs(read); //if ignored, skip _processing\n\n\n  if (childrenIgnored(this, read)) return cb();\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n};\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n  });\n};\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries) return cb(); // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n  var matchedEntries = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n\n      if (m) matchedEntries.push(e);\n    }\n  } //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n\n  var len = matchedEntries.length; // If there are no matched entries, then nothing matches.\n\n  if (len === 0) return cb(); // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n\n      if (prefix) {\n        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e);\n      }\n\n      this._emitMatch(index, e);\n    } // This was the last one, and no stats were needed\n\n\n    return cb();\n  } // now test all matched entries as stand-ins for that part\n  // of the pattern.\n\n\n  remain.shift();\n\n  for (var i = 0; i < len; i++) {\n    var e = matchedEntries[i];\n    var newPattern;\n\n    if (prefix) {\n      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n    }\n\n    this._process([e].concat(remain), index, inGlobStar, cb);\n  }\n\n  cb();\n};\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted) return;\n  if (isIgnored(this, e)) return;\n\n  if (this.paused) {\n    this._emitQueue.push([index, e]);\n\n    return;\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e);\n  if (this.mark) e = this._mark(e);\n  if (this.absolute) e = abs;\n  if (this.matches[index][e]) return;\n\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c)) return;\n  }\n\n  this.matches[index][e] = true;\n  var st = this.statCache[abs];\n  if (st) this.emit('stat', e, st);\n  this.emit('match', e);\n};\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted) return; // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n\n  if (this.follow) return this._readdir(abs, false, cb);\n  var lstatkey = 'lstat\\0' + abs;\n  var self = this;\n  var lstatcb = inflight(lstatkey, lstatcb_);\n  if (lstatcb) self.fs.lstat(abs, lstatcb);\n\n  function lstatcb_(er, lstat) {\n    if (er && er.code === 'ENOENT') return cb();\n    var isSym = lstat && lstat.isSymbolicLink();\n    self.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE';\n      cb();\n    } else self._readdir(abs, false, cb);\n  }\n};\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted) return;\n  cb = inflight('readdir\\0' + abs + '\\0' + inGlobStar, cb);\n  if (!cb) return; //console.error('RD %j %j', +inGlobStar, abs)\n\n  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE') return cb();\n    if (Array.isArray(c)) return cb(null, c);\n  }\n\n  var self = this;\n  self.fs.readdir(abs, readdirCb(this, abs, cb));\n};\n\nfunction readdirCb(self, abs, cb) {\n  return function (er, entries) {\n    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);\n  };\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted) return; // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n      if (abs === '/') e = abs + e;else e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n\n  this.cache[abs] = entries;\n  return cb(null, entries);\n};\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted) return; // handle errors, and cache the information\n\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n\n    case 'ENOTDIR':\n      // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n\n      this.cache[abs] = 'FILE';\n\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        this.emit('error', error);\n        this.abort();\n      }\n\n      break;\n\n    case 'ENOENT': // not terribly unusual\n\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break;\n\n    default:\n      // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n\n      if (this.strict) {\n        this.emit('error', er); // If the error is handled, then we abort\n        // if not, we threw out of here\n\n        this.abort();\n      }\n\n      if (!this.silent) console.error('glob error', er);\n      break;\n  }\n\n  return cb();\n};\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n  });\n};\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries) return cb(); // test without the globstar, and with every child both below\n  // and replacing the globstar.\n\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [prefix] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state\n\n  this._process(noGlobStar, index, false, cb);\n\n  var isSym = this.symlinks[abs];\n  var len = entries.length; // If it's a symlink, and we're in a globstar, then stop\n\n  if (isSym && inGlobStar) return cb();\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state\n\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n\n    this._process(instead, index, true, cb);\n\n    var below = gspref.concat(entries[i], remain);\n\n    this._process(below, index, true, cb);\n  }\n\n  cb();\n};\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this;\n\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb);\n  });\n};\n\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n  //console.error('ps2', prefix, exists)\n  if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results\n\n  if (!exists) return cb();\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix);\n    } else {\n      prefix = path.resolve(this.root, prefix);\n      if (trail) prefix += '/';\n    }\n  }\n\n  if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/'); // Mark this as a match\n\n  this._emitMatch(index, prefix);\n\n  cb();\n}; // Returns either 'DIR', 'FILE', or false\n\n\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f);\n\n  var needDir = f.slice(-1) === '/';\n  if (f.length > this.maxLength) return cb();\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it\n\n    if (!needDir || c === 'DIR') return cb(null, c);\n    if (needDir && c === 'FILE') return cb(); // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists;\n  var stat = this.statCache[abs];\n\n  if (stat !== undefined) {\n    if (stat === false) return cb(null, stat);else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE';\n      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);\n    }\n  }\n\n  var self = this;\n  var statcb = inflight('stat\\0' + abs, lstatcb_);\n  if (statcb) self.fs.lstat(abs, statcb);\n\n  function lstatcb_(er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);\n      });\n    } else {\n      self._stat2(f, abs, er, lstat, cb);\n    }\n  }\n};\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false;\n    return cb();\n  }\n\n  var needDir = f.slice(-1) === '/';\n  this.statCache[abs] = stat;\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);\n  var c = true;\n  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n  this.cache[abs] = this.cache[abs] || c;\n  if (needDir && c === 'FILE') return cb();\n  return cb(null, c, stat);\n};","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\nvar escSlash = '\\0SLASH' + Math.random() + '\\0';\nvar escOpen = '\\0OPEN' + Math.random() + '\\0';\nvar escClose = '\\0CLOSE' + Math.random() + '\\0';\nvar escComma = '\\0COMMA' + Math.random() + '\\0';\nvar escPeriod = '\\0PERIOD' + Math.random() + '\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash).split('\\\\{').join(escOpen).split('\\\\}').join(escClose).split('\\\\,').join(escComma).split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');\n} // Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\n\n\nfunction parseCommaParts(str) {\n  if (!str) return [''];\n  var parts = [];\n  var m = balanced('{', '}', str);\n  if (!m) return str.split(',');\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n  p[p.length - 1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n\n  if (post.length) {\n    p[p.length - 1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str) return []; // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\n\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\n\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n  var m = balanced('{', '}', str);\n  if (!m) return [str]; // no need to expand pre, since it is guaranteed to be free of brace-sets\n\n  var pre = m.pre;\n  var post = m.post.length ? expand(m.post, false) : [''];\n\n  if (/\\$$/.test(m.pre)) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n\n      return [str];\n    }\n\n    var n;\n\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n\n        if (n.length === 1) {\n          return post.map(function (p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    } // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n\n\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length);\n      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n      var test = lte;\n      var reverse = y < x;\n\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n\n      var pad = n.some(isPadded);\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\') c = '';\n        } else {\n          c = String(i);\n\n          if (pad) {\n            var need = width - c.length;\n\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0) c = '-' + z + c.slice(1);else c = z + c;\n            }\n          }\n        }\n\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion) expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}","const isWindows = typeof process === 'object' && process && process.platform === 'win32';\nmodule.exports = isWindows ? {\n  sep: '\\\\'\n} : {\n  sep: '/'\n};","const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern); // shortcut: comments match nothing.\n\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n\n  return new Minimatch(pattern, options).match(p);\n};\n\nmodule.exports = minimatch;\n\nconst path = require('./lib/path.js');\n\nminimatch.sep = path.sep;\nconst GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n\nconst expand = require('brace-expansion');\n\nconst plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n}; // any single thing other than /\n// don't need to escape / when using new RegExp()\n\nconst qmark = '[^/]'; // * => any number of characters\n\nconst star = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\n\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'; // not a ^ or / followed by a dot,\n// followed by anything, any number of times.\n\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'; // \"abc\" -> { a:true, b:true, c:true }\n\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true;\n  return set;\n}, {}); // characters that need to be escaped in RegExp.\n\n\nconst reSpecials = charSet('().*{}+?[]^$\\\\!'); // characters that indicate we have to add the pattern start\n\nconst addPatternStartSet = charSet('[.('); // normalizes slashes.\n\nconst slashSplit = /\\/+/;\n\nminimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);\n\nconst ext = (a, b = {}) => {\n  const t = {};\n  Object.keys(a).forEach(k => t[k] = a[k]);\n  Object.keys(b).forEach(k => t[k] = b[k]);\n  return t;\n};\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n\n  const orig = minimatch;\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options));\n\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor(pattern, options) {\n      super(pattern, ext(def, options));\n    }\n\n  };\n\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch;\n\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));\n\n  m.defaults = options => orig.defaults(ext(def, options));\n\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));\n\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));\n\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));\n\n  return m;\n}; // Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\n\n\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern); // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n\n  return expand(pattern);\n};\n\nconst MAX_PATTERN_LENGTH = 1024 * 64;\n\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n}; // parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\n\nconst SUBPARSE = Symbol('subparse');\n\nminimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n\n  return list;\n}; // replace stuff like \\* with *\n\n\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1');\n\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\nclass Minimatch {\n  constructor(pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial; // make the set of regexps etc.\n\n    this.make();\n  }\n\n  debug() {}\n\n  make() {\n    const pattern = this.pattern;\n    const options = this.options; // empty patterns and comments match nothing.\n\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n\n    if (!pattern) {\n      this.empty = true;\n      return;\n    } // step 1: figure out negation, etc.\n\n\n    this.parseNegate(); // step 2: expand braces\n\n    let set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = (...args) => console.error(...args);\n    this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n\n    set = this.globParts = set.map(s => s.split(slashSplit));\n    this.debug(this.pattern, set); // glob --> regexps\n\n    set = set.map((s, si, set) => s.map(this.parse, this));\n    this.debug(this.pattern, set); // filter out everything that didn't compile properly.\n\n    set = set.filter(s => s.indexOf(false) === -1);\n    this.debug(this.pattern, set);\n    this.set = set;\n  }\n\n  parseNegate() {\n    if (this.options.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n  } // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n\n\n  matchOne(file, pattern, partial) {\n    var options = this.options;\n    this.debug('matchOne', {\n      'this': this,\n      file: file,\n      pattern: pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f); // should be impossible.\n      // some invalid regexp stuff in the set.\n\n      /* istanbul ignore if */\n\n      if (p === false) return false;\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]); // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n\n        var fr = fi;\n        var pr = pi + 1;\n\n        if (pr === pl) {\n          this.debug('** at the end'); // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n\n          return true;\n        } // ok, let's see if we can swallow whatever we can.\n\n\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.\n\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee); // found a match.\n\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            } // ** swallows a segment, and continue.\n\n\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        } // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n\n        /* istanbul ignore if */\n\n\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) return true;\n        }\n\n        return false;\n      } // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n\n\n      var hit;\n\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = f.match(p);\n        this.debug('pattern match', p, f, hit);\n      }\n\n      if (!hit) return false;\n    } // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n\n\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else\n      /* istanbul ignore else */\n      if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === '';\n      } // should be unreachable.\n\n    /* istanbul ignore next */\n\n\n    throw new Error('wtf?');\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options);\n  }\n\n  parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    const options = this.options; // shortcuts\n\n    if (pattern === '**') {\n      if (!options.noglobstar) return GLOBSTAR;else pattern = '*';\n    }\n\n    if (pattern === '') return '';\n    let re = '';\n    let hasMagic = !!options.nocase;\n    let escaping = false; // ? => one single character\n\n    const patternListStack = [];\n    const negativeLists = [];\n    let stateChar;\n    let inClass = false;\n    let reClassStart = -1;\n    let classStart = -1;\n    let cs;\n    let pl;\n    let sp; // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n\n    const patternStart = pattern.charAt(0) === '.' ? '' // anything\n    // not (start or / followed by . or .. followed by / or end)\n    : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star;\n            hasMagic = true;\n            break;\n\n          case '?':\n            re += qmark;\n            hasMagic = true;\n            break;\n\n          default:\n            re += '\\\\' + stateChar;\n            break;\n        }\n\n        this.debug('clearStateChar %j %j', stateChar, re);\n        stateChar = false;\n      }\n    };\n\n    for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.\n\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false;\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\';\n        }\n\n        re += c;\n        escaping = false;\n        continue;\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/':\n          {\n            // Should already be path-split by now.\n            return false;\n          }\n\n        case '\\\\':\n          clearStateChar();\n          escaping = true;\n          continue;\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n\n          if (inClass) {\n            this.debug('  in class');\n            if (c === '!' && i === classStart + 1) c = '^';\n            re += c;\n            continue;\n          } // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n\n\n          this.debug('call clearStateChar %j', stateChar);\n          clearStateChar();\n          stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n\n          if (options.noext) clearStateChar();\n          continue;\n\n        case '(':\n          if (inClass) {\n            re += '(';\n            continue;\n          }\n\n          if (!stateChar) {\n            re += '\\\\(';\n            continue;\n          }\n\n          patternListStack.push({\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close\n          }); // negation is (?:(?!js)[^/]*)\n\n          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n          this.debug('plType %j %j', stateChar, re);\n          stateChar = false;\n          continue;\n\n        case ')':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\)';\n            continue;\n          }\n\n          clearStateChar();\n          hasMagic = true;\n          pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n\n          re += pl.close;\n\n          if (pl.type === '!') {\n            negativeLists.push(pl);\n          }\n\n          pl.reEnd = re.length;\n          continue;\n\n        case '|':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\|';\n            continue;\n          }\n\n          clearStateChar();\n          re += '|';\n          continue;\n        // these are mostly the same in regexp and glob\n\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar();\n\n          if (inClass) {\n            re += '\\\\' + c;\n            continue;\n          }\n\n          inClass = true;\n          classStart = i;\n          reClassStart = re.length;\n          re += c;\n          continue;\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c;\n            continue;\n          } // handle the case where we left a class open.\n          // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n\n\n          cs = pattern.substring(classStart + 1, i);\n\n          try {\n            RegExp('[' + cs + ']');\n          } catch (er) {\n            // not a valid class!\n            sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n            hasMagic = hasMagic || sp[1];\n            inClass = false;\n            continue;\n          } // finish up the class.\n\n\n          hasMagic = true;\n          inClass = false;\n          re += c;\n          continue;\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar();\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\';\n          }\n\n          re += c;\n          break;\n      } // switch\n\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n\n\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.substr(classStart + 1);\n      sp = this.parse(cs, SUBPARSE);\n      re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n      hasMagic = hasMagic || sp[1];\n    } // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n\n\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail;\n      tail = re.slice(pl.reStart + pl.open.length);\n      this.debug('setting tail', re, pl); // maybe some even number of \\, then maybe 1 \\, followed by a |\n\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\';\n        } // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n\n\n        return $1 + $1 + $2 + '|';\n      });\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n      const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n      hasMagic = true;\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n    } // handle trailing things that only matter at the very end.\n\n\n    clearStateChar();\n\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\';\n    } // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n\n\n    const addPatternStart = addPatternStartSet[re.charAt(0)]; // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n];\n      const nlBefore = re.slice(0, nl.reStart);\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n      let nlAfter = re.slice(nl.reEnd);\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n\n      const openParensBefore = nlBefore.split('(').length - 1;\n      let cleanAfter = nlAfter;\n\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n      }\n\n      nlAfter = cleanAfter;\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : '';\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    } // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n\n\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re;\n    }\n\n    if (addPatternStart) {\n      re = patternStart + re;\n    } // parsing just a piece of a larger pattern.\n\n\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic];\n    } // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n\n\n    if (!hasMagic) {\n      return globUnescape(pattern);\n    }\n\n    const flags = options.nocase ? 'i' : '';\n\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re\n      });\n    } catch (er)\n    /* istanbul ignore next - should be impossible */\n    {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.');\n    }\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n\n    const set = this.set;\n\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = options.nocase ? 'i' : ''; // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n\n    let re = set.map(pattern => {\n      pattern = pattern.map(p => typeof p === 'string' ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p);\n        }\n\n        return set;\n      }, []);\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {\n          return;\n        }\n\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i + 1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i + 1];\n          } else {\n            pattern[i] = twoStar;\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i - 1] += '(?:\\\\\\/|' + twoStar + ')?';\n        } else {\n          pattern[i - 1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i + 1];\n          pattern[i + 1] = GLOBSTAR;\n        }\n      });\n      return pattern.filter(p => p !== GLOBSTAR).join('/');\n    }).join('|'); // must match entire pattern\n    // ending in a * or ** will make it less strict.\n\n    re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.\n\n    if (this.negate) re = '^(?!' + re + ').*$';\n\n    try {\n      this.regexp = new RegExp(re, flags);\n    } catch (ex)\n    /* istanbul ignore next - should be impossible */\n    {\n      this.regexp = false;\n    }\n\n    return this.regexp;\n  }\n\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern); // short-circuit in the case of busted things.\n    // comments, etc.\n\n    if (this.comment) return false;\n    if (this.empty) return f === '';\n    if (f === '/' && partial) return true;\n    const options = this.options; // windows: need to use /, not \\\n\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/');\n    } // treat the test path as a set of pathparts.\n\n\n    f = f.split(slashSplit);\n    this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set;\n    this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment\n\n    let filename;\n\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i];\n      if (filename) break;\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = f;\n\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n\n      const hit = this.matchOne(file, pattern, partial);\n\n      if (hit) {\n        if (options.flipNegate) return true;\n        return !this.negate;\n      }\n    } // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n\n\n    if (options.flipNegate) return false;\n    return this.negate;\n  }\n\n  static defaults(def) {\n    return minimatch.defaults(def).Minimatch;\n  }\n\n}\n\nminimatch.Minimatch = Minimatch;","module.exports = globSync;\nglobSync.GlobSync = GlobSync;\n\nvar rp = require('fs.realpath');\n\nvar minimatch = require('minimatch');\n\nvar Minimatch = minimatch.Minimatch;\n\nvar Glob = require('./glob.js').Glob;\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar assert = require('assert');\n\nvar isAbsolute = require('path').isAbsolute;\n\nvar common = require('./common.js');\n\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\n\nfunction globSync(pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n  return new GlobSync(pattern, options).found;\n}\n\nfunction GlobSync(pattern, options) {\n  if (!pattern) throw new Error('must provide pattern');\n  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n  if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);\n  setopts(this, pattern, options);\n  if (this.noprocess) return this;\n  var n = this.minimatch.set.length;\n  this.matches = new Array(n);\n\n  for (var i = 0; i < n; i++) {\n    this._process(this.minimatch.set[i], i, false);\n  }\n\n  this._finish();\n}\n\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync);\n\n  if (this.realpath) {\n    var self = this;\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null);\n\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p);\n          var real = rp.realpathSync(p, self.realpathCache);\n          set[real] = true;\n        } catch (er) {\n          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;\n        }\n      }\n    });\n  }\n\n  common.finish(this);\n};\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync); // Get the first [n] parts of pattern that are all strings.\n\n  var n = 0;\n\n  while (typeof pattern[n] === 'string') {\n    n++;\n  } // now n is the index of the first one that is *not* a string.\n  // See if there's anything else\n\n\n  var prefix;\n\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index);\n\n      return;\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break;\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break;\n  }\n\n  var remain = pattern.slice(n); // get the list of entries.\n\n  var read;\n  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.map(function (p) {\n    return typeof p === 'string' ? p : '[*]';\n  }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n    read = prefix;\n  } else read = prefix;\n\n  var abs = this._makeAbs(read); //if ignored, skip processing\n\n\n  if (childrenIgnored(this, read)) return;\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n};\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar); // if the abs isn't a dir, then nothing can match!\n\n\n  if (!entries) return; // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n  var matchedEntries = [];\n\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n\n      if (m) matchedEntries.push(e);\n    }\n  }\n\n  var len = matchedEntries.length; // If there are no matched entries, then nothing matches.\n\n  if (len === 0) return; // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n\n      if (prefix) {\n        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e);\n      }\n\n      this._emitMatch(index, e);\n    } // This was the last one, and no stats were needed\n\n\n    return;\n  } // now test all matched entries as stand-ins for that part\n  // of the pattern.\n\n\n  remain.shift();\n\n  for (var i = 0; i < len; i++) {\n    var e = matchedEntries[i];\n    var newPattern;\n    if (prefix) newPattern = [prefix, e];else newPattern = [e];\n\n    this._process(newPattern.concat(remain), index, inGlobStar);\n  }\n};\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e)) return;\n\n  var abs = this._makeAbs(e);\n\n  if (this.mark) e = this._mark(e);\n\n  if (this.absolute) {\n    e = abs;\n  }\n\n  if (this.matches[index][e]) return;\n\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c)) return;\n  }\n\n  this.matches[index][e] = true;\n  if (this.stat) this._stat(e);\n};\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow) return this._readdir(abs, false);\n  var entries;\n  var lstat;\n  var stat;\n\n  try {\n    lstat = this.fs.lstatSync(abs);\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null;\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink();\n  this.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n\n  if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);\n  return entries;\n};\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries;\n  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE') return null;\n    if (Array.isArray(c)) return c;\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs));\n  } catch (er) {\n    this._readdirError(abs, er);\n\n    return null;\n  }\n};\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n      if (abs === '/') e = abs + e;else e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n\n  this.cache[abs] = entries; // mark and cache dir-ness\n\n  return entries;\n};\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n\n    case 'ENOTDIR':\n      // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n\n      this.cache[abs] = 'FILE';\n\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        throw error;\n      }\n\n      break;\n\n    case 'ENOENT': // not terribly unusual\n\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break;\n\n    default:\n      // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n      if (this.strict) throw er;\n      if (!this.silent) console.error('glob error', er);\n      break;\n  }\n};\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar); // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n\n\n  if (!entries) return; // test without the globstar, and with every child both below\n  // and replacing the globstar.\n\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [prefix] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state\n\n  this._process(noGlobStar, index, false);\n\n  var len = entries.length;\n  var isSym = this.symlinks[abs]; // If it's a symlink, and we're in a globstar, then stop\n\n  if (isSym && inGlobStar) return;\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state\n\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n\n    this._process(instead, index, true);\n\n    var below = gspref.concat(entries[i], remain);\n\n    this._process(below, index, true);\n  }\n};\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix);\n\n  if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results\n\n  if (!exists) return;\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix);\n    } else {\n      prefix = path.resolve(this.root, prefix);\n      if (trail) prefix += '/';\n    }\n  }\n\n  if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/'); // Mark this as a match\n\n  this._emitMatch(index, prefix);\n}; // Returns either 'DIR', 'FILE', or false\n\n\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f);\n\n  var needDir = f.slice(-1) === '/';\n  if (f.length > this.maxLength) return false;\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it\n\n    if (!needDir || c === 'DIR') return c;\n    if (needDir && c === 'FILE') return false; // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists;\n  var stat = this.statCache[abs];\n\n  if (!stat) {\n    var lstat;\n\n    try {\n      lstat = this.fs.lstatSync(abs);\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false;\n        return false;\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs);\n      } catch (er) {\n        stat = lstat;\n      }\n    } else {\n      stat = lstat;\n    }\n  }\n\n  this.statCache[abs] = stat;\n  var c = true;\n  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n  this.cache[abs] = this.cache[abs] || c;\n  if (needDir && c === 'FILE') return false;\n  return c;\n};\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p);\n};\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f);\n};","var wrappy = require('wrappy');\n\nvar reqs = Object.create(null);\n\nvar once = require('once');\n\nmodule.exports = wrappy(inflight);\n\nfunction inflight(key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb);\n    return null;\n  } else {\n    reqs[key] = [cb];\n    return makeres(key);\n  }\n}\n\nfunction makeres(key) {\n  return once(function RES() {\n    var cbs = reqs[key];\n    var len = cbs.length;\n    var args = slice(arguments); // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args);\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len);\n        process.nextTick(function () {\n          RES.apply(null, args);\n        });\n      } else {\n        delete reqs[key];\n      }\n    }\n  });\n}\n\nfunction slice(args) {\n  var length = args.length;\n  var array = [];\n\n  for (var i = 0; i < length; i++) array[i] = args[i];\n\n  return array;\n}","try {\n  var util = require('util');\n  /* istanbul ignore next */\n\n\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = require('./inherits_browser.js');\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function () {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}","const fs = require('fs');\n\nconst ID3Definitions = require(\"./src/ID3Definitions\");\n\nconst ID3Frames = require('./src/ID3Frames');\n\nconst ID3Util = require('./src/ID3Util');\n/*\r\n**  Used specification: http://id3.org/id3v2.3.0\r\n*/\n\n/**\r\n * Write passed tags to a file/buffer\r\n * @param tags - Object containing tags to be written\r\n * @param filebuffer - Can contain a filepath string or buffer\r\n * @param fn - (optional) Function for async version\r\n * @returns {boolean|Buffer|Error}\r\n */\n\n\nmodule.exports.write = function (tags, filebuffer, fn) {\n  let completeTag = this.create(tags);\n\n  if (filebuffer instanceof Buffer) {\n    filebuffer = this.removeTagsFromBuffer(filebuffer) || filebuffer;\n    let completeBuffer = Buffer.concat([completeTag, filebuffer]);\n\n    if (fn && typeof fn === 'function') {\n      fn(null, completeBuffer);\n      return;\n    } else {\n      return completeBuffer;\n    }\n  }\n\n  if (fn && typeof fn === 'function') {\n    try {\n      fs.readFile(filebuffer, function (err, data) {\n        if (err) {\n          fn(err);\n          return;\n        }\n\n        data = this.removeTagsFromBuffer(data) || data;\n        let rewriteFile = Buffer.concat([completeTag, data]);\n        fs.writeFile(filebuffer, rewriteFile, 'binary', err => {\n          fn(err);\n        });\n      }.bind(this));\n    } catch (err) {\n      fn(err);\n    }\n  } else {\n    try {\n      let data = fs.readFileSync(filebuffer);\n      data = this.removeTagsFromBuffer(data) || data;\n      let rewriteFile = Buffer.concat([completeTag, data]);\n      fs.writeFileSync(filebuffer, rewriteFile, 'binary');\n      return true;\n    } catch (err) {\n      return err;\n    }\n  }\n};\n/**\r\n * Creates a buffer containing the ID3 Tag\r\n * @param tags - Object containing tags to be written\r\n * @param fn fn - (optional) Function for async version\r\n * @returns {Buffer}\r\n */\n\n\nmodule.exports.create = function (tags, fn) {\n  let frames = []; //  Create & push a header for the ID3-Frame\n\n  const header = Buffer.alloc(10);\n  header.fill(0);\n  header.write(\"ID3\", 0); //File identifier\n\n  header.writeUInt16BE(0x0300, 3); //Version 2.3.0  --  03 00\n\n  header.writeUInt16BE(0x0000, 5); //Flags 00\n  //Last 4 bytes are used for header size, but have to be inserted later, because at this point, its size is not clear.\n\n  frames.push(header);\n  frames = frames.concat(this.createBuffersFromTags(tags)); //  Calculate frame size of ID3 body to insert into header\n\n  let totalSize = 0;\n  frames.forEach(frame => {\n    totalSize += frame.length;\n  }); //  Don't count ID3 header itself\n\n  totalSize -= 10; //  ID3 header size uses only 7 bits of a byte, bit shift is needed\n\n  let size = ID3Util.encodeSize(totalSize); //  Write bytes to ID3 frame header, which is the first frame\n\n  frames[0].writeUInt8(size[0], 6);\n  frames[0].writeUInt8(size[1], 7);\n  frames[0].writeUInt8(size[2], 8);\n  frames[0].writeUInt8(size[3], 9);\n\n  if (fn && typeof fn === 'function') {\n    fn(Buffer.concat(frames));\n  } else {\n    return Buffer.concat(frames);\n  }\n};\n/**\r\n * Returns array of buffers created by tags specified in the tags argument\r\n * @param tags - Object containing tags to be written\r\n * @returns {Array}\r\n */\n\n\nmodule.exports.createBuffersFromTags = function (tags) {\n  let frames = [];\n  if (!tags) return frames;\n  const rawObject = Object.keys(tags).reduce((acc, val) => {\n    if (ID3Definitions.FRAME_IDENTIFIERS.v3[val] !== undefined) {\n      acc[ID3Definitions.FRAME_IDENTIFIERS.v3[val]] = tags[val];\n    } else {\n      acc[val] = tags[val];\n    }\n\n    return acc;\n  }, {});\n  Object.keys(rawObject).forEach((specName, index) => {\n    let frame; // Check if invalid specName\n\n    if (specName.length !== 4) {\n      return;\n    }\n\n    if (ID3Frames[specName] !== undefined) {\n      frame = ID3Frames[specName].create(rawObject[specName], 3, this);\n    } else if (specName.startsWith('T')) {\n      frame = ID3Frames.GENERIC_TEXT.create(specName, rawObject[specName], 3);\n    } else if (specName.startsWith('W')) {\n      if (ID3Util.getSpecOptions(specName, 3).multiple && rawObject[specName] instanceof Array && rawObject[specName].length > 0) {\n        frame = Buffer.alloc(0); // deduplicate array\n\n        for (let url of [...new Set(rawObject[specName])]) {\n          frame = Buffer.concat([frame, ID3Frames.GENERIC_URL.create(specName, url, 3)]);\n        }\n      } else {\n        frame = ID3Frames.GENERIC_URL.create(specName, rawObject[specName], 3);\n      }\n    }\n\n    if (frame instanceof Buffer) {\n      frames.push(frame);\n    }\n  });\n  return frames;\n};\n/**\r\n * Read ID3-Tags from passed buffer/filepath\r\n * @param filebuffer - Can contain a filepath string or buffer\r\n * @param options - (optional) Object containing options\r\n * @param fn - (optional) Function for async version\r\n * @returns {boolean}\r\n */\n\n\nmodule.exports.read = function (filebuffer, options, fn) {\n  if (!options || typeof options === 'function') {\n    fn = fn || options;\n    options = {};\n  }\n\n  if (!fn || typeof fn !== 'function') {\n    if (typeof filebuffer === \"string\" || filebuffer instanceof String) {\n      filebuffer = fs.readFileSync(filebuffer);\n    }\n\n    return this.getTagsFromBuffer(filebuffer, options);\n  } else {\n    if (typeof filebuffer === \"string\" || filebuffer instanceof String) {\n      fs.readFile(filebuffer, function (err, data) {\n        if (err) {\n          fn(err, null);\n        } else {\n          fn(null, this.getTagsFromBuffer(data, options));\n        }\n      }.bind(this));\n    } else {\n      fn(null, this.getTagsFromBuffer(filebuffer, options));\n    }\n  }\n};\n/**\r\n * Update ID3-Tags from passed buffer/filepath\r\n * @param tags - Object containing tags to be written\r\n * @param filebuffer - Can contain a filepath string or buffer\r\n * @param options - (optional) Object containing options\r\n * @param fn - (optional) Function for async version\r\n * @returns {boolean|Buffer|Error}\r\n */\n\n\nmodule.exports.update = function (tags, filebuffer, options, fn) {\n  if (!options || typeof options === 'function') {\n    fn = fn || options;\n    options = {};\n  }\n\n  const rawTags = Object.keys(tags).reduce((acc, val) => {\n    if (ID3Definitions.FRAME_IDENTIFIERS.v3[val] !== undefined) {\n      acc[ID3Definitions.FRAME_IDENTIFIERS.v3[val]] = tags[val];\n    } else {\n      acc[val] = tags[val];\n    }\n\n    return acc;\n  }, {});\n\n  const updateFn = currentTags => {\n    currentTags = currentTags.raw || {};\n    Object.keys(rawTags).map(specName => {\n      const options = ID3Util.getSpecOptions(specName, 3);\n      const cCompare = {};\n\n      if (options.multiple && currentTags[specName] && rawTags[specName]) {\n        if (options.updateCompareKey) {\n          currentTags[specName].forEach((cTag, index) => {\n            cCompare[cTag[options.updateCompareKey]] = index;\n          });\n        }\n\n        if (!(rawTags[specName] instanceof Array)) rawTags[specName] = [rawTags[specName]];\n        rawTags[specName].forEach((rTag, index) => {\n          const comparison = cCompare[rTag[options.updateCompareKey]];\n\n          if (comparison !== undefined) {\n            currentTags[specName][comparison] = rTag;\n          } else {\n            currentTags[specName].push(rTag);\n          }\n        });\n      } else {\n        currentTags[specName] = rawTags[specName];\n      }\n    });\n    return currentTags;\n  };\n\n  if (!fn || typeof fn !== 'function') {\n    return this.write(updateFn(this.read(filebuffer, options)), filebuffer);\n  } else {\n    this.read(filebuffer, (err, currentTags) => {\n      this.write(updateFn(this.read(filebuffer, options)), filebuffer, fn);\n    });\n  }\n};\n\nmodule.exports.getTagsFromBuffer = function (filebuffer, options) {\n  let framePosition = ID3Util.getFramePosition(filebuffer);\n\n  if (framePosition === -1) {\n    return this.getTagsFromFrames([], 3, options);\n  }\n\n  const frameSize = ID3Util.decodeSize(filebuffer.slice(framePosition + 6, framePosition + 10)) + 10;\n  let ID3Frame = Buffer.alloc(frameSize + 1);\n  filebuffer.copy(ID3Frame, 0, framePosition); //ID3 version e.g. 3 if ID3v2.3.0\n\n  let ID3Version = ID3Frame[3];\n  const tagFlags = ID3Util.parseTagHeaderFlags(ID3Frame);\n  let extendedHeaderOffset = 0;\n\n  if (tagFlags.extendedHeader) {\n    if (ID3Version === 3) {\n      extendedHeaderOffset = 4 + filebuffer.readUInt32BE(10);\n    } else if (ID3Version === 4) {\n      extendedHeaderOffset = ID3Util.decodeSize(filebuffer.slice(10, 14));\n    }\n  }\n\n  let ID3FrameBody = Buffer.alloc(frameSize - 10 - extendedHeaderOffset);\n  filebuffer.copy(ID3FrameBody, 0, framePosition + 10 + extendedHeaderOffset);\n  let frames = this.getFramesFromID3Body(ID3FrameBody, ID3Version, options);\n  return this.getTagsFromFrames(frames, ID3Version, options);\n};\n\nmodule.exports.getFramesFromID3Body = function (ID3FrameBody, ID3Version, options = {}) {\n  let currentPosition = 0;\n  let frames = [];\n\n  if (!ID3FrameBody || !(ID3FrameBody instanceof Buffer)) {\n    return frames;\n  }\n\n  let identifierSize = 4;\n  let textframeHeaderSize = 10;\n\n  if (ID3Version === 2) {\n    identifierSize = 3;\n    textframeHeaderSize = 6;\n  }\n\n  while (currentPosition < ID3FrameBody.length && ID3FrameBody[currentPosition] !== 0x00) {\n    let bodyFrameHeader = Buffer.alloc(textframeHeaderSize);\n    ID3FrameBody.copy(bodyFrameHeader, 0, currentPosition);\n    let decodeSize = false;\n\n    if (ID3Version === 4) {\n      decodeSize = true;\n    }\n\n    let bodyFrameSize = ID3Util.getFrameSize(bodyFrameHeader, decodeSize, ID3Version);\n\n    if (bodyFrameSize + 10 > ID3FrameBody.length - currentPosition) {\n      break;\n    }\n\n    const specName = bodyFrameHeader.toString('utf8', 0, identifierSize);\n\n    if (options.exclude instanceof Array && options.exclude.includes(specName) || options.include instanceof Array && !options.include.includes(specName)) {\n      currentPosition += bodyFrameSize + textframeHeaderSize;\n      continue;\n    }\n\n    const frameHeaderFlags = ID3Util.parseFrameHeaderFlags(bodyFrameHeader, ID3Version);\n    let bodyFrameBuffer = Buffer.alloc(bodyFrameSize);\n    ID3FrameBody.copy(bodyFrameBuffer, 0, currentPosition + textframeHeaderSize + (frameHeaderFlags.dataLengthIndicator ? 4 : 0)); //  Size of sub frame + its header\n\n    currentPosition += bodyFrameSize + textframeHeaderSize;\n    frames.push({\n      name: specName,\n      flags: frameHeaderFlags,\n      body: frameHeaderFlags.unsynchronisation ? ID3Util.processUnsynchronisedBuffer(bodyFrameBuffer) : bodyFrameBuffer\n    });\n  }\n\n  return frames;\n};\n\nmodule.exports.getTagsFromFrames = function (frames, ID3Version, options = {}) {\n  let tags = {};\n  let raw = {};\n  frames.forEach((frame, index) => {\n    const specName = ID3Version === 2 ? ID3Definitions.FRAME_IDENTIFIERS.v3[ID3Definitions.FRAME_INTERNAL_IDENTIFIERS.v2[frame.name]] : frame.name;\n    const identifier = ID3Version === 2 ? ID3Definitions.FRAME_INTERNAL_IDENTIFIERS.v2[frame.name] : ID3Definitions.FRAME_INTERNAL_IDENTIFIERS.v3[frame.name];\n\n    if (!specName || !identifier) {\n      return;\n    }\n\n    let decoded;\n\n    if (ID3Frames[specName]) {\n      decoded = ID3Frames[specName].read(frame.body, ID3Version, this);\n    } else if (specName.startsWith('T')) {\n      decoded = ID3Frames.GENERIC_TEXT.read(frame.body, ID3Version);\n    } else if (specName.startsWith('W')) {\n      decoded = ID3Frames.GENERIC_URL.read(frame.body, ID3Version);\n    }\n\n    if (decoded) {\n      if (ID3Util.getSpecOptions(specName, ID3Version).multiple) {\n        if (!options.onlyRaw) {\n          if (!tags[identifier]) tags[identifier] = [];\n          tags[identifier].push(decoded);\n        }\n\n        if (!options.noRaw) {\n          if (!raw[specName]) raw[specName] = [];\n          raw[specName].push(decoded);\n        }\n      } else {\n        if (!options.onlyRaw) {\n          tags[identifier] = decoded;\n        }\n\n        if (!options.noRaw) {\n          raw[specName] = decoded;\n        }\n      }\n    }\n  });\n  if (options.onlyRaw) return raw;\n  if (options.noRaw) return tags;\n  tags.raw = raw;\n  return tags;\n};\n/**\r\n * Checks and removes already written ID3-Frames from a buffer\r\n * @param data - Buffer\r\n * @returns {boolean|Buffer}\r\n */\n\n\nmodule.exports.removeTagsFromBuffer = function (data) {\n  let framePosition = ID3Util.getFramePosition(data);\n\n  if (framePosition === -1) {\n    return data;\n  }\n\n  let hSize = Buffer.from([data[framePosition + 6], data[framePosition + 7], data[framePosition + 8], data[framePosition + 9]]);\n\n  if ((hSize[0] | hSize[1] | hSize[2] | hSize[3]) & 0x80) {\n    //  Invalid tag size (msb not 0)\n    return false;\n  }\n\n  if (data.length >= framePosition + 10) {\n    const size = ID3Util.decodeSize(data.slice(framePosition + 6, framePosition + 10));\n    return Buffer.concat([data.slice(0, framePosition), data.slice(framePosition + size + 10)]);\n  } else {\n    return data;\n  }\n};\n/**\r\n * Checks and removes already written ID3-Frames from a file\r\n * @param filepath - Filepath to file\r\n * @param fn - (optional) Function for async usage\r\n * @returns {boolean|Error}\r\n */\n\n\nmodule.exports.removeTags = function (filepath, fn) {\n  if (!fn || typeof fn !== 'function') {\n    let data;\n\n    try {\n      data = fs.readFileSync(filepath);\n    } catch (e) {\n      return e;\n    }\n\n    let newData = this.removeTagsFromBuffer(data);\n\n    if (!newData) {\n      return false;\n    }\n\n    try {\n      fs.writeFileSync(filepath, newData, 'binary');\n    } catch (e) {\n      return e;\n    }\n\n    return true;\n  } else {\n    fs.readFile(filepath, function (err, data) {\n      if (err) {\n        fn(err);\n      }\n\n      let newData = this.removeTagsFromBuffer(data);\n\n      if (!newData) {\n        fn(err);\n        return;\n      }\n\n      fs.writeFile(filepath, newData, 'binary', function (err) {\n        if (err) {\n          fn(err);\n        } else {\n          fn(false);\n        }\n      });\n    }.bind(this));\n  }\n};\n\nmodule.exports.Promise = {\n  write: (tags, file) => {\n    return new Promise((resolve, reject) => {\n      this.write(tags, file, (err, ret) => {\n        if (err) reject(err);else resolve(ret);\n      });\n    });\n  },\n  update: (tags, file) => {\n    return new Promise((resolve, reject) => {\n      this.update(tags, file, (err, ret) => {\n        if (err) reject(err);else resolve(ret);\n      });\n    });\n  },\n  create: tags => {\n    return new Promise(resolve => {\n      this.create(tags, buffer => {\n        resolve(buffer);\n      });\n    });\n  },\n  read: (file, options) => {\n    return new Promise((resolve, reject) => {\n      this.read(file, options, (err, ret) => {\n        if (err) reject(err);else resolve(ret);\n      });\n    });\n  },\n  removeTags: filepath => {\n    return new Promise((resolve, reject) => {\n      this.removeTags(filepath, err => {\n        if (err) reject(err);else resolve();\n      });\n    });\n  }\n};","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED; // Class DBCSCodec reads and initializes mapping tables.\n\n\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\"); // Load tables.\n\n  var mappingTable = codecOptions.table(); // Decode tables: MBCS -> Unicode.\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n\n  this.decodeTableSeq = []; // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]); // Load & create GB18030 tables when needed.\n\n\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n    // Add GB18030 common decode nodes.\n\n    var commonThirdByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0));\n    var commonFourthByteNodeIdx = this.decodeTables.length;\n    this.decodeTables.push(UNASSIGNED_NODE.slice(0)); // Fill out the tree\n\n    var firstByteNode = this.decodeTables[0];\n\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];\n\n      for (var j = 0x30; j <= 0x39; j++) {\n        if (secondByteNode[j] === UNASSIGNED) {\n          secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;\n        } else if (secondByteNode[j] > NODE_START) {\n          throw new Error(\"gb18030 decode tables conflict at byte 2\");\n        }\n\n        var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];\n\n        for (var k = 0x81; k <= 0xFE; k++) {\n          if (thirdByteNode[k] === UNASSIGNED) {\n            thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;\n          } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {\n            continue;\n          } else if (thirdByteNode[k] > NODE_START) {\n            throw new Error(\"gb18030 decode tables conflict at byte 3\");\n          }\n\n          var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];\n\n          for (var l = 0x30; l <= 0x39; l++) {\n            if (fourthByteNode[l] === UNASSIGNED) fourthByteNode[l] = GB18030_CODE;\n          }\n        }\n      }\n    }\n  }\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode; // Encode tables: Unicode -> DBCS.\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n\n  this.encodeTable = []; // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n\n  this.encodeTableSeq = []; // Some chars can be decoded, but need not be encoded.\n\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  } // Use decode trie to recursively fill out encode tables.\n\n  this._fillEncodeTable(0, 0, skipEncodeChars); // Add more encoding pairs when needed.\n\n\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder; // Decoder helpers\n\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n\n  for (; addr > 0; addr >>>= 8) bytes.push(addr & 0xFF);\n\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n\n  return node;\n};\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16); // Choose the decoding node where we'll write our chars.\n\n  var writeTable = this._getDecodeTrieNode(curAddr);\n\n  curAddr = curAddr & 0xFF; // Write all other elements of the chunk to the table.\n\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}; // Encoder helpers\n\n\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n\n  return this.encodeTable[high];\n};\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  var node;\n\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  } // Traverse the character tree, allocating new nodes as needed.\n\n\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  } // Set the leaf to given dbcsCode.\n\n\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n  var hasValues = false;\n  var subNodeEmpty = {};\n\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n\n    if (uCode >= 0) {\n      this._setEncodeChar(uCode, mbCode);\n\n      hasValues = true;\n    } else if (uCode <= NODE_START) {\n      var subNodeIdx = NODE_START - uCode;\n\n      if (!subNodeEmpty[subNodeIdx]) {\n        // Skip empty subtrees (they are too large in gb18030).\n        var newPrefix = mbCode << 8 >>> 0; // NOTE: '>>> 0' keeps 32-bit num positive.\n\n        if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars)) hasValues = true;else subNodeEmpty[subNodeIdx] = true;\n      }\n    } else if (uCode <= SEQ_START) {\n      this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n\n      hasValues = true;\n    }\n  }\n\n  return hasValues;\n}; // == Encoder ==================================================================\n\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined; // Static data\n\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n      leadSurrogate = this.leadSurrogate,\n      seqObj = this.seqObj,\n      nextChar = -1,\n      i = 0,\n      j = 0;\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    } // 1. Handle surrogates.\n\n\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode; // Double lead surrogate found.\n\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n\n      leadSurrogate = -1;\n    } // 2. Convert uCode character.\n\n\n    var dbcsCode = UNASSIGNED;\n\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {// TODO: What if we have no default? (resCode == undefined)\n          // Then, we should write first char of the sequence as-is and try the rest recursively.\n          // Didn't do it for now because no encoding has this situation yet.\n          // Currently, just skip the sequence and write current char.\n        }\n      }\n\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    } // 3. Write dbcsCode character.\n\n\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else if (dbcsCode < 0x1000000) {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    } else {\n      newBuf[j++] = dbcsCode >>> 24;\n      newBuf[j++] = dbcsCode >>> 16 & 0xFF;\n      newBuf[j++] = dbcsCode >>> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n      j = 0;\n\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {// See todo above.\n    }\n\n    this.seqObj = undefined;\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n\n  return newBuf.slice(0, j);\n}; // Export for testing\n\n\nDBCSEncoder.prototype.findIdx = findIdx; // == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBytes = []; // Static data\n\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n      nodeIdx = this.nodeIdx,\n      prevBytes = this.prevBytes,\n      prevOffset = this.prevBytes.length,\n      seqStart = -this.prevBytes.length,\n      // idx of the start of current parsed sequence.\n  uCode;\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset]; // Lookup in current trie node.\n\n    var uCode = this.decodeTables[nodeIdx][curByte];\n\n    if (uCode >= 0) {// Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n      i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.\n    } else if (uCode === GB18030_CODE) {\n      if (i >= 3) {\n        var ptr = (buf[i - 3] - 0x81) * 12600 + (buf[i - 2] - 0x30) * 1260 + (buf[i - 1] - 0x81) * 10 + (curByte - 0x30);\n      } else {\n        var ptr = (prevBytes[i - 3 + prevOffset] - 0x81) * 12600 + ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) - 0x30) * 1260 + ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) - 0x81) * 10 + (curByte - 0x30);\n      }\n\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte); // Write the character to buffer, handling higher planes using surrogate pair.\n\n\n    if (uCode >= 0x10000) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 | uCode >> 10;\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 | uCode & 0x3FF;\n    }\n\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8; // Reset trie node.\n\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n\n  this.nodeIdx = nodeIdx;\n  this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));\n  return newBuf.slice(0, j).toString('ucs2');\n};\n\nDBCSDecoder.prototype.end = function () {\n  var ret = ''; // Try to parse all remaining chars.\n\n  while (this.prevBytes.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var bytesArr = this.prevBytes.slice(1); // Parse remaining as usual.\n\n    this.prevBytes = [];\n    this.nodeIdx = 0;\n    if (bytesArr.length > 0) ret += this.write(bytesArr);\n  }\n\n  this.prevBytes = [];\n  this.nodeIdx = 0;\n  return ret;\n}; // Binary search for GB18030. Returns largest i such that table[i] <= val.\n\n\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n      r = table.length;\n\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + (r - l + 1 >> 1);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n\n  return l;\n}","\"use strict\"; // Description of supported double byte encodings and aliases.\n// Tables are not require()-d until they are needed to speed up library load.\n// require()-s are direct to support Browserify.\n\nmodule.exports = {\n  // == Japanese/ShiftJIS ====================================================\n  // All japanese encodings are based on JIS X set of standards:\n  // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.\n  // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. \n  //              Has several variations in 1978, 1983, 1990 and 1997.\n  // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.\n  // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.\n  //              2 planes, first is superset of 0208, second - revised 0212.\n  //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)\n  // Byte encodings are:\n  //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte\n  //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.\n  //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.\n  //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.\n  //               0x00-0x7F       - lower part of 0201\n  //               0x8E, 0xA1-0xDF - upper part of 0201\n  //               (0xA1-0xFE)x2   - 0208 plane (94x94).\n  //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).\n  //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.\n  //               Used as-is in ISO2022 family.\n  //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, \n  //                0201-1976 Roman, 0208-1978, 0208-1983.\n  //  * ISO2022-JP-1: Adds esc seq for 0212-1990.\n  //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.\n  //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.\n  //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.\n  //\n  // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.\n  //\n  // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html\n  'shiftjis': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/shiftjis.json');\n    },\n    encodeAdd: {\n      '\\u00a5': 0x5C,\n      '\\u203E': 0x7E\n    },\n    encodeSkipVals: [{\n      from: 0xED40,\n      to: 0xF940\n    }]\n  },\n  'csshiftjis': 'shiftjis',\n  'mskanji': 'shiftjis',\n  'sjis': 'shiftjis',\n  'windows31j': 'shiftjis',\n  'ms31j': 'shiftjis',\n  'xsjis': 'shiftjis',\n  'windows932': 'shiftjis',\n  'ms932': 'shiftjis',\n  '932': 'shiftjis',\n  'cp932': 'shiftjis',\n  'eucjp': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/eucjp.json');\n    },\n    encodeAdd: {\n      '\\u00a5': 0x5C,\n      '\\u203E': 0x7E\n    }\n  },\n  // TODO: KDDI extension to Shift_JIS\n  // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.\n  // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.\n  // == Chinese/GBK ==========================================================\n  // http://en.wikipedia.org/wiki/GBK\n  // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder\n  // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936\n  'gb2312': 'cp936',\n  'gb231280': 'cp936',\n  'gb23121980': 'cp936',\n  'csgb2312': 'cp936',\n  'csiso58gb231280': 'cp936',\n  'euccn': 'cp936',\n  // Microsoft's CP936 is a subset and approximation of GBK.\n  'windows936': 'cp936',\n  'ms936': 'cp936',\n  '936': 'cp936',\n  'cp936': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp936.json');\n    }\n  },\n  // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.\n  'gbk': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));\n    }\n  },\n  'xgbk': 'gbk',\n  'isoir58': 'gbk',\n  // GB18030 is an algorithmic extension of GBK.\n  // Main source: https://www.w3.org/TR/encoding/#gbk-encoder\n  // http://icu-project.org/docs/papers/gb18030.html\n  // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml\n  // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0\n  'gb18030': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp936.json').concat(require('./tables/gbk-added.json'));\n    },\n    gb18030: function () {\n      return require('./tables/gb18030-ranges.json');\n    },\n    encodeSkipVals: [0x80],\n    encodeAdd: {\n      '': 0xA2E3\n    }\n  },\n  'chinese': 'gb18030',\n  // == Korean ===============================================================\n  // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.\n  'windows949': 'cp949',\n  'ms949': 'cp949',\n  '949': 'cp949',\n  'cp949': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp949.json');\n    }\n  },\n  'cseuckr': 'cp949',\n  'csksc56011987': 'cp949',\n  'euckr': 'cp949',\n  'isoir149': 'cp949',\n  'korean': 'cp949',\n  'ksc56011987': 'cp949',\n  'ksc56011989': 'cp949',\n  'ksc5601': 'cp949',\n  // == Big5/Taiwan/Hong Kong ================================================\n  // There are lots of tables for Big5 and cp950. Please see the following links for history:\n  // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html\n  // Variations, in roughly number of defined chars:\n  //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT\n  //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/\n  //  * Big5-2003 (Taiwan standard) almost superset of cp950.\n  //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.\n  //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. \n  //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.\n  //    Plus, it has 4 combining sequences.\n  //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299\n  //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.\n  //    Implementations are not consistent within browsers; sometimes labeled as just big5.\n  //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.\n  //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31\n  //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.\n  //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt\n  //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt\n  // \n  // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder\n  // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.\n  'windows950': 'cp950',\n  'ms950': 'cp950',\n  '950': 'cp950',\n  'cp950': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp950.json');\n    }\n  },\n  // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.\n  'big5': 'big5hkscs',\n  'big5hkscs': {\n    type: '_dbcs',\n    table: function () {\n      return require('./tables/cp950.json').concat(require('./tables/big5-added.json'));\n    },\n    encodeSkipVals: [0xa2cc]\n  },\n  'cnbig5': 'big5hkscs',\n  'csbig5': 'big5hkscs',\n  'xxbig5': 'big5hkscs'\n};","\"use strict\"; // Update this array if you add/rename/remove files in this directory.\n// We support Browserify by skipping automatic module discovery and requiring modules directly.\n\nvar modules = [require(\"./internal\"), require(\"./utf32\"), require(\"./utf16\"), require(\"./utf7\"), require(\"./sbcs-codec\"), require(\"./sbcs-data\"), require(\"./sbcs-data-generated\"), require(\"./dbcs-codec\"), require(\"./dbcs-data\")]; // Put all encoding/alias/codec definitions to single object and export it.\n\nfor (var i = 0; i < modules.length; i++) {\n  var module = modules[i];\n\n  for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];\n}","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Export Node.js internal encodings.\n\n\nmodule.exports = {\n  // Encodings\n  utf8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  cesu8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  unicode11utf8: \"utf8\",\n  ucs2: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  utf16le: \"ucs2\",\n  binary: {\n    type: \"_internal\"\n  },\n  base64: {\n    type: \"_internal\"\n  },\n  hex: {\n    type: \"_internal\"\n  },\n  // Codec.\n  _internal: InternalCodec\n}; //------------------------------------------------------------------------------\n\nfunction InternalCodec(codecOptions, iconv) {\n  this.enc = codecOptions.encodingName;\n  this.bomAware = codecOptions.bomAware;\n  if (this.enc === \"base64\") this.encoder = InternalEncoderBase64;else if (this.enc === \"cesu8\") {\n    this.enc = \"utf8\"; // Use utf8 for decoding.\n\n    this.encoder = InternalEncoderCesu8; // Add decoder for versions of Node not supporting CESU-8\n\n    if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {\n      this.decoder = InternalDecoderCesu8;\n      this.defaultCharUnicode = iconv.defaultCharUnicode;\n    }\n  }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder;\nInternalCodec.prototype.decoder = InternalDecoder; //------------------------------------------------------------------------------\n// We use node.js internal decoder. Its signature is the same as ours.\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nif (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.\n  StringDecoder.prototype.end = function () {};\n\nfunction InternalDecoder(options, codec) {\n  this.decoder = new StringDecoder(codec.enc);\n}\n\nInternalDecoder.prototype.write = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    buf = Buffer.from(buf);\n  }\n\n  return this.decoder.write(buf);\n};\n\nInternalDecoder.prototype.end = function () {\n  return this.decoder.end();\n}; //------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\n\nfunction InternalEncoder(options, codec) {\n  this.enc = codec.enc;\n}\n\nInternalEncoder.prototype.write = function (str) {\n  return Buffer.from(str, this.enc);\n};\n\nInternalEncoder.prototype.end = function () {}; //------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\n\nfunction InternalEncoderBase64(options, codec) {\n  this.prevStr = '';\n}\n\nInternalEncoderBase64.prototype.write = function (str) {\n  str = this.prevStr + str;\n  var completeQuads = str.length - str.length % 4;\n  this.prevStr = str.slice(completeQuads);\n  str = str.slice(0, completeQuads);\n  return Buffer.from(str, \"base64\");\n};\n\nInternalEncoderBase64.prototype.end = function () {\n  return Buffer.from(this.prevStr, \"base64\");\n}; //------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\n\nfunction InternalEncoderCesu8(options, codec) {}\n\nInternalEncoderCesu8.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length * 3),\n      bufIdx = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var charCode = str.charCodeAt(i); // Naive implementation, but it works because CESU-8 is especially easy\n    // to convert from UTF-16 (which all JS strings are encoded in).\n\n    if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {\n      buf[bufIdx++] = 0xC0 + (charCode >>> 6);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    } else {\n      // charCode will always be < 0x10000 in javascript.\n      buf[bufIdx++] = 0xE0 + (charCode >>> 12);\n      buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    }\n  }\n\n  return buf.slice(0, bufIdx);\n};\n\nInternalEncoderCesu8.prototype.end = function () {}; //------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\n\nfunction InternalDecoderCesu8(options, codec) {\n  this.acc = 0;\n  this.contBytes = 0;\n  this.accBytes = 0;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n}\n\nInternalDecoderCesu8.prototype.write = function (buf) {\n  var acc = this.acc,\n      contBytes = this.contBytes,\n      accBytes = this.accBytes,\n      res = '';\n\n  for (var i = 0; i < buf.length; i++) {\n    var curByte = buf[i];\n\n    if ((curByte & 0xC0) !== 0x80) {\n      // Leading byte\n      if (contBytes > 0) {\n        // Previous code is invalid\n        res += this.defaultCharUnicode;\n        contBytes = 0;\n      }\n\n      if (curByte < 0x80) {\n        // Single-byte code\n        res += String.fromCharCode(curByte);\n      } else if (curByte < 0xE0) {\n        // Two-byte code\n        acc = curByte & 0x1F;\n        contBytes = 1;\n        accBytes = 1;\n      } else if (curByte < 0xF0) {\n        // Three-byte code\n        acc = curByte & 0x0F;\n        contBytes = 2;\n        accBytes = 1;\n      } else {\n        // Four or more are not supported for CESU-8.\n        res += this.defaultCharUnicode;\n      }\n    } else {\n      // Continuation byte\n      if (contBytes > 0) {\n        // We're waiting for it.\n        acc = acc << 6 | curByte & 0x3f;\n        contBytes--;\n        accBytes++;\n\n        if (contBytes === 0) {\n          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n          if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else // Actually add character.\n            res += String.fromCharCode(acc);\n        }\n      } else {\n        // Unexpected continuation byte\n        res += this.defaultCharUnicode;\n      }\n    }\n  }\n\n  this.acc = acc;\n  this.contBytes = contBytes;\n  this.accBytes = accBytes;\n  return res;\n};\n\nInternalDecoderCesu8.prototype.end = function () {\n  var res = 0;\n  if (this.contBytes > 0) res += this.defaultCharUnicode;\n  return res;\n};","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\n\nexports._sbcs = SBCSCodec;\n\nfunction SBCSCodec(codecOptions, iconv) {\n  if (!codecOptions) throw new Error(\"SBCS codec is called without the data.\"); // Prepare char buffer for decoding.\n\n  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\";\n\n    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);\n\n    codecOptions.chars = asciiString + codecOptions.chars;\n  }\n\n  this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2'); // Encoding buffer.\n\n  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n  for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n  this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\nfunction SBCSEncoder(options, codec) {\n  this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length);\n\n  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];\n\n  return buf;\n};\n\nSBCSEncoder.prototype.end = function () {};\n\nfunction SBCSDecoder(options, codec) {\n  this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf;\n  var newBuf = Buffer.alloc(buf.length * 2);\n  var idx1 = 0,\n      idx2 = 0;\n\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = decodeBuf[idx1];\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];\n  }\n\n  return newBuf.toString('ucs2');\n};\n\nSBCSDecoder.prototype.end = function () {};","\"use strict\"; // Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.\n\nmodule.exports = {\n  \"437\": \"cp437\",\n  \"737\": \"cp737\",\n  \"775\": \"cp775\",\n  \"850\": \"cp850\",\n  \"852\": \"cp852\",\n  \"855\": \"cp855\",\n  \"856\": \"cp856\",\n  \"857\": \"cp857\",\n  \"858\": \"cp858\",\n  \"860\": \"cp860\",\n  \"861\": \"cp861\",\n  \"862\": \"cp862\",\n  \"863\": \"cp863\",\n  \"864\": \"cp864\",\n  \"865\": \"cp865\",\n  \"866\": \"cp866\",\n  \"869\": \"cp869\",\n  \"874\": \"windows874\",\n  \"922\": \"cp922\",\n  \"1046\": \"cp1046\",\n  \"1124\": \"cp1124\",\n  \"1125\": \"cp1125\",\n  \"1129\": \"cp1129\",\n  \"1133\": \"cp1133\",\n  \"1161\": \"cp1161\",\n  \"1162\": \"cp1162\",\n  \"1163\": \"cp1163\",\n  \"1250\": \"windows1250\",\n  \"1251\": \"windows1251\",\n  \"1252\": \"windows1252\",\n  \"1253\": \"windows1253\",\n  \"1254\": \"windows1254\",\n  \"1255\": \"windows1255\",\n  \"1256\": \"windows1256\",\n  \"1257\": \"windows1257\",\n  \"1258\": \"windows1258\",\n  \"28591\": \"iso88591\",\n  \"28592\": \"iso88592\",\n  \"28593\": \"iso88593\",\n  \"28594\": \"iso88594\",\n  \"28595\": \"iso88595\",\n  \"28596\": \"iso88596\",\n  \"28597\": \"iso88597\",\n  \"28598\": \"iso88598\",\n  \"28599\": \"iso88599\",\n  \"28600\": \"iso885910\",\n  \"28601\": \"iso885911\",\n  \"28603\": \"iso885913\",\n  \"28604\": \"iso885914\",\n  \"28605\": \"iso885915\",\n  \"28606\": \"iso885916\",\n  \"windows874\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win874\": \"windows874\",\n  \"cp874\": \"windows874\",\n  \"windows1250\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1250\": \"windows1250\",\n  \"cp1250\": \"windows1250\",\n  \"windows1251\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1251\": \"windows1251\",\n  \"cp1251\": \"windows1251\",\n  \"windows1252\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1252\": \"windows1252\",\n  \"cp1252\": \"windows1252\",\n  \"windows1253\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1253\": \"windows1253\",\n  \"cp1253\": \"windows1253\",\n  \"windows1254\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1254\": \"windows1254\",\n  \"cp1254\": \"windows1254\",\n  \"windows1255\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1255\": \"windows1255\",\n  \"cp1255\": \"windows1255\",\n  \"windows1256\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1256\": \"windows1256\",\n  \"cp1256\": \"windows1256\",\n  \"windows1257\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1257\": \"windows1257\",\n  \"cp1257\": \"windows1257\",\n  \"windows1258\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"win1258\": \"windows1258\",\n  \"cp1258\": \"windows1258\",\n  \"iso88591\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28591\": \"iso88591\",\n  \"iso88592\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28592\": \"iso88592\",\n  \"iso88593\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28593\": \"iso88593\",\n  \"iso88594\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28594\": \"iso88594\",\n  \"iso88595\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28595\": \"iso88595\",\n  \"iso88596\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28596\": \"iso88596\",\n  \"iso88597\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28597\": \"iso88597\",\n  \"iso88598\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28598\": \"iso88598\",\n  \"iso88599\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28599\": \"iso88599\",\n  \"iso885910\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28600\": \"iso885910\",\n  \"iso885911\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28601\": \"iso885911\",\n  \"iso885913\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28603\": \"iso885913\",\n  \"iso885914\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28604\": \"iso885914\",\n  \"iso885915\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28605\": \"iso885915\",\n  \"iso885916\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp28606\": \"iso885916\",\n  \"cp437\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm437\": \"cp437\",\n  \"csibm437\": \"cp437\",\n  \"cp737\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm737\": \"cp737\",\n  \"csibm737\": \"cp737\",\n  \"cp775\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm775\": \"cp775\",\n  \"csibm775\": \"cp775\",\n  \"cp850\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm850\": \"cp850\",\n  \"csibm850\": \"cp850\",\n  \"cp852\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm852\": \"cp852\",\n  \"csibm852\": \"cp852\",\n  \"cp855\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm855\": \"cp855\",\n  \"csibm855\": \"cp855\",\n  \"cp856\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm856\": \"cp856\",\n  \"csibm856\": \"cp856\",\n  \"cp857\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm857\": \"cp857\",\n  \"csibm857\": \"cp857\",\n  \"cp858\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm858\": \"cp858\",\n  \"csibm858\": \"cp858\",\n  \"cp860\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm860\": \"cp860\",\n  \"csibm860\": \"cp860\",\n  \"cp861\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm861\": \"cp861\",\n  \"csibm861\": \"cp861\",\n  \"cp862\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm862\": \"cp862\",\n  \"csibm862\": \"cp862\",\n  \"cp863\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm863\": \"cp863\",\n  \"csibm863\": \"cp863\",\n  \"cp864\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"ibm864\": \"cp864\",\n  \"csibm864\": \"cp864\",\n  \"cp865\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm865\": \"cp865\",\n  \"csibm865\": \"cp865\",\n  \"cp866\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm866\": \"cp866\",\n  \"csibm866\": \"cp866\",\n  \"cp869\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm869\": \"cp869\",\n  \"csibm869\": \"cp869\",\n  \"cp922\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm922\": \"cp922\",\n  \"csibm922\": \"cp922\",\n  \"cp1046\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1046\": \"cp1046\",\n  \"csibm1046\": \"cp1046\",\n  \"cp1124\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1124\": \"cp1124\",\n  \"csibm1124\": \"cp1124\",\n  \"cp1125\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1125\": \"cp1125\",\n  \"csibm1125\": \"cp1125\",\n  \"cp1129\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1129\": \"cp1129\",\n  \"csibm1129\": \"cp1129\",\n  \"cp1133\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1133\": \"cp1133\",\n  \"csibm1133\": \"cp1133\",\n  \"cp1161\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1161\": \"cp1161\",\n  \"csibm1161\": \"cp1161\",\n  \"cp1162\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1162\": \"cp1162\",\n  \"csibm1162\": \"cp1162\",\n  \"cp1163\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ibm1163\": \"cp1163\",\n  \"csibm1163\": \"cp1163\",\n  \"maccroatian\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"maccyrillic\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macgreek\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"maciceland\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macroman\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macromania\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macthai\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macturkish\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macukraine\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8r\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8u\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8ru\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"koi8t\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"armscii8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \")(.,-\"\n  },\n  \"rk1048\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"tcvn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0003\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"georgianacademy\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"georgianps\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"pt154\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"viscii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0003\\u0004\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0015\\u0016\\u0017\\u0018\\u001a\\u001b\\u001c\\u001d\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n  },\n  \"iso646cn\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}\"\n  },\n  \"iso646jp\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}\"\n  },\n  \"hproman8\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"macintosh\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"ascii\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"tis620\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  }\n};","\"use strict\"; // Manually added data to be used by sbcs codec in addition to generated one.\n\nmodule.exports = {\n  // Not supported by iconv, not sure why.\n  \"10029\": \"maccenteuro\",\n  \"maccenteuro\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"808\": \"cp808\",\n  \"ibm808\": \"cp808\",\n  \"cp808\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"mik\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\"\n  },\n  \"cp720\": {\n    \"type\": \"_sbcs\",\n    \"chars\": \"\\x80\\x81\\x84\\x86\\x8d\\x8e\\x8f\\x90\\u0651\\u0652\\u064b\\u064c\\u064d\\u064e\\u064f\\u0650\\u00a0\"\n  },\n  // Aliases of generated encodings.\n  \"ascii8bit\": \"ascii\",\n  \"usascii\": \"ascii\",\n  \"ansix34\": \"ascii\",\n  \"ansix341968\": \"ascii\",\n  \"ansix341986\": \"ascii\",\n  \"csascii\": \"ascii\",\n  \"cp367\": \"ascii\",\n  \"ibm367\": \"ascii\",\n  \"isoir6\": \"ascii\",\n  \"iso646us\": \"ascii\",\n  \"iso646irv\": \"ascii\",\n  \"us\": \"ascii\",\n  \"latin1\": \"iso88591\",\n  \"latin2\": \"iso88592\",\n  \"latin3\": \"iso88593\",\n  \"latin4\": \"iso88594\",\n  \"latin5\": \"iso88599\",\n  \"latin6\": \"iso885910\",\n  \"latin7\": \"iso885913\",\n  \"latin8\": \"iso885914\",\n  \"latin9\": \"iso885915\",\n  \"latin10\": \"iso885916\",\n  \"csisolatin1\": \"iso88591\",\n  \"csisolatin2\": \"iso88592\",\n  \"csisolatin3\": \"iso88593\",\n  \"csisolatin4\": \"iso88594\",\n  \"csisolatincyrillic\": \"iso88595\",\n  \"csisolatinarabic\": \"iso88596\",\n  \"csisolatingreek\": \"iso88597\",\n  \"csisolatinhebrew\": \"iso88598\",\n  \"csisolatin5\": \"iso88599\",\n  \"csisolatin6\": \"iso885910\",\n  \"l1\": \"iso88591\",\n  \"l2\": \"iso88592\",\n  \"l3\": \"iso88593\",\n  \"l4\": \"iso88594\",\n  \"l5\": \"iso88599\",\n  \"l6\": \"iso885910\",\n  \"l7\": \"iso885913\",\n  \"l8\": \"iso885914\",\n  \"l9\": \"iso885915\",\n  \"l10\": \"iso885916\",\n  \"isoir14\": \"iso646jp\",\n  \"isoir57\": \"iso646cn\",\n  \"isoir100\": \"iso88591\",\n  \"isoir101\": \"iso88592\",\n  \"isoir109\": \"iso88593\",\n  \"isoir110\": \"iso88594\",\n  \"isoir144\": \"iso88595\",\n  \"isoir127\": \"iso88596\",\n  \"isoir126\": \"iso88597\",\n  \"isoir138\": \"iso88598\",\n  \"isoir148\": \"iso88599\",\n  \"isoir157\": \"iso885910\",\n  \"isoir166\": \"tis620\",\n  \"isoir179\": \"iso885913\",\n  \"isoir199\": \"iso885914\",\n  \"isoir203\": \"iso885915\",\n  \"isoir226\": \"iso885916\",\n  \"cp819\": \"iso88591\",\n  \"ibm819\": \"iso88591\",\n  \"cyrillic\": \"iso88595\",\n  \"arabic\": \"iso88596\",\n  \"arabic8\": \"iso88596\",\n  \"ecma114\": \"iso88596\",\n  \"asmo708\": \"iso88596\",\n  \"greek\": \"iso88597\",\n  \"greek8\": \"iso88597\",\n  \"ecma118\": \"iso88597\",\n  \"elot928\": \"iso88597\",\n  \"hebrew\": \"iso88598\",\n  \"hebrew8\": \"iso88598\",\n  \"turkish\": \"iso88599\",\n  \"turkish8\": \"iso88599\",\n  \"thai\": \"iso885911\",\n  \"thai8\": \"iso885911\",\n  \"celtic\": \"iso885914\",\n  \"celtic8\": \"iso885914\",\n  \"isoceltic\": \"iso885914\",\n  \"tis6200\": \"tis620\",\n  \"tis62025291\": \"tis620\",\n  \"tis62025330\": \"tis620\",\n  \"10000\": \"macroman\",\n  \"10006\": \"macgreek\",\n  \"10007\": \"maccyrillic\",\n  \"10079\": \"maciceland\",\n  \"10081\": \"macturkish\",\n  \"cspc8codepage437\": \"cp437\",\n  \"cspc775baltic\": \"cp775\",\n  \"cspc850multilingual\": \"cp850\",\n  \"cspcp852\": \"cp852\",\n  \"cspc862latinhebrew\": \"cp862\",\n  \"cpgr\": \"cp869\",\n  \"msee\": \"cp1250\",\n  \"mscyrl\": \"cp1251\",\n  \"msansi\": \"cp1252\",\n  \"msgreek\": \"cp1253\",\n  \"msturk\": \"cp1254\",\n  \"mshebr\": \"cp1255\",\n  \"msarab\": \"cp1256\",\n  \"winbaltrim\": \"cp1257\",\n  \"cp20866\": \"koi8r\",\n  \"20866\": \"koi8r\",\n  \"ibm878\": \"koi8r\",\n  \"cskoi8r\": \"koi8r\",\n  \"cp21866\": \"koi8u\",\n  \"21866\": \"koi8u\",\n  \"ibm1168\": \"koi8u\",\n  \"strk10482002\": \"rk1048\",\n  \"tcvn5712\": \"tcvn\",\n  \"tcvn57121\": \"tcvn\",\n  \"gb198880\": \"iso646cn\",\n  \"cn\": \"iso646cn\",\n  \"csiso14jisc6220ro\": \"iso646jp\",\n  \"jisc62201969ro\": \"iso646jp\",\n  \"jp\": \"iso646jp\",\n  \"cshproman8\": \"hproman8\",\n  \"r8\": \"hproman8\",\n  \"roman8\": \"hproman8\",\n  \"xroman8\": \"hproman8\",\n  \"ibm1051\": \"hproman8\",\n  \"mac\": \"macintosh\",\n  \"csmacintosh\": \"macintosh\"\n};","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js\n// == UTF16-BE codec. ==========================================================\n\n\nexports.utf16be = Utf16BECodec;\n\nfunction Utf16BECodec() {}\n\nUtf16BECodec.prototype.encoder = Utf16BEEncoder;\nUtf16BECodec.prototype.decoder = Utf16BEDecoder;\nUtf16BECodec.prototype.bomAware = true; // -- Encoding\n\nfunction Utf16BEEncoder() {}\n\nUtf16BEEncoder.prototype.write = function (str) {\n  var buf = Buffer.from(str, 'ucs2');\n\n  for (var i = 0; i < buf.length; i += 2) {\n    var tmp = buf[i];\n    buf[i] = buf[i + 1];\n    buf[i + 1] = tmp;\n  }\n\n  return buf;\n};\n\nUtf16BEEncoder.prototype.end = function () {}; // -- Decoding\n\n\nfunction Utf16BEDecoder() {\n  this.overflowByte = -1;\n}\n\nUtf16BEDecoder.prototype.write = function (buf) {\n  if (buf.length == 0) return '';\n  var buf2 = Buffer.alloc(buf.length + 1),\n      i = 0,\n      j = 0;\n\n  if (this.overflowByte !== -1) {\n    buf2[0] = buf[0];\n    buf2[1] = this.overflowByte;\n    i = 1;\n    j = 2;\n  }\n\n  for (; i < buf.length - 1; i += 2, j += 2) {\n    buf2[j] = buf[i + 1];\n    buf2[j + 1] = buf[i];\n  }\n\n  this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;\n  return buf2.slice(0, j).toString('ucs2');\n};\n\nUtf16BEDecoder.prototype.end = function () {\n  this.overflowByte = -1;\n}; // == UTF-16 codec =============================================================\n// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.\n// Defaults to UTF-16LE, as it's prevalent and default in Node.\n// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le\n// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});\n// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).\n\n\nexports.utf16 = Utf16Codec;\n\nfunction Utf16Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n}\n\nUtf16Codec.prototype.encoder = Utf16Encoder;\nUtf16Codec.prototype.decoder = Utf16Decoder; // -- Encoding (pass-through)\n\nfunction Utf16Encoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder('utf-16le', options);\n}\n\nUtf16Encoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\nUtf16Encoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction Utf16Decoder(options, codec) {\n  this.decoder = null;\n  this.initialBufs = [];\n  this.initialBufsLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\nUtf16Decoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBufs.push(buf);\n    this.initialBufsLen += buf.length;\n    if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);\n\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.write(buf);\n};\n\nUtf16Decoder.prototype.end = function () {\n  if (!this.decoder) {\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);\n\n    var trail = this.decoder.end();\n    if (trail) resStr += trail;\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.end();\n};\n\nfunction detectEncoding(bufs, defaultEncoding) {\n  var b = [];\n  var charsProcessed = 0;\n  var asciiCharsLE = 0,\n      asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.\n\n  outer_loop: for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i];\n\n    for (var j = 0; j < buf.length; j++) {\n      b.push(buf[j]);\n\n      if (b.length === 2) {\n        if (charsProcessed === 0) {\n          // Check BOM first.\n          if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';\n          if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';\n        }\n\n        if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;\n        if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;\n        b.length = 0;\n        charsProcessed++;\n\n        if (charsProcessed >= 100) {\n          break outer_loop;\n        }\n      }\n    }\n  } // Make decisions.\n  // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.\n  // So, we count ASCII as if it was LE or BE, and decide from that.\n\n\n  if (asciiCharsBE > asciiCharsLE) return 'utf-16be';\n  if (asciiCharsBE < asciiCharsLE) return 'utf-16le'; // Couldn't decide (likely all zeros or not enough data).\n\n  return defaultEncoding || 'utf-16le';\n}","'use strict';\n\nvar Buffer = require('safer-buffer').Buffer; // == UTF32-LE/BE codec. ==========================================================\n\n\nexports._utf32 = Utf32Codec;\n\nfunction Utf32Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n  this.bomAware = true;\n  this.isLE = codecOptions.isLE;\n}\n\nexports.utf32le = {\n  type: '_utf32',\n  isLE: true\n};\nexports.utf32be = {\n  type: '_utf32',\n  isLE: false\n}; // Aliases\n\nexports.ucs4le = 'utf32le';\nexports.ucs4be = 'utf32be';\nUtf32Codec.prototype.encoder = Utf32Encoder;\nUtf32Codec.prototype.decoder = Utf32Decoder; // -- Encoding\n\nfunction Utf32Encoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.highSurrogate = 0;\n}\n\nUtf32Encoder.prototype.write = function (str) {\n  var src = Buffer.from(str, 'ucs2');\n  var dst = Buffer.alloc(src.length * 2);\n  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;\n  var offset = 0;\n\n  for (var i = 0; i < src.length; i += 2) {\n    var code = src.readUInt16LE(i);\n    var isHighSurrogate = 0xD800 <= code && code < 0xDC00;\n    var isLowSurrogate = 0xDC00 <= code && code < 0xE000;\n\n    if (this.highSurrogate) {\n      if (isHighSurrogate || !isLowSurrogate) {\n        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n        // (technically wrong, but expected by some applications, like Windows file names).\n        write32.call(dst, this.highSurrogate, offset);\n        offset += 4;\n      } else {\n        // Create 32-bit value from high and low surrogates;\n        var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;\n        write32.call(dst, codepoint, offset);\n        offset += 4;\n        this.highSurrogate = 0;\n        continue;\n      }\n    }\n\n    if (isHighSurrogate) this.highSurrogate = code;else {\n      // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n      // unpaired high surrogates.\n      write32.call(dst, code, offset);\n      offset += 4;\n      this.highSurrogate = 0;\n    }\n  }\n\n  if (offset < dst.length) dst = dst.slice(0, offset);\n  return dst;\n};\n\nUtf32Encoder.prototype.end = function () {\n  // Treat any leftover high surrogate as a semi-valid independent character.\n  if (!this.highSurrogate) return;\n  var buf = Buffer.alloc(4);\n  if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);\n  this.highSurrogate = 0;\n  return buf;\n}; // -- Decoding\n\n\nfunction Utf32Decoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);\n  this.overflow = [];\n}\n\nUtf32Decoder.prototype.write = function (src) {\n  if (src.length === 0) return '';\n  var i = 0;\n  var codepoint = 0;\n  var dst = Buffer.alloc(src.length + 4);\n  var offset = 0;\n  var isLE = this.isLE;\n  var overflow = this.overflow;\n  var badChar = this.badChar;\n\n  if (overflow.length > 0) {\n    for (; i < src.length && overflow.length < 4; i++) overflow.push(src[i]);\n\n    if (overflow.length === 4) {\n      // NOTE: codepoint is a signed int32 and can be negative.\n      // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).\n      if (isLE) {\n        codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;\n      } else {\n        codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;\n      }\n\n      overflow.length = 0;\n      offset = _writeCodepoint(dst, offset, codepoint, badChar);\n    }\n  } // Main loop. Should be as optimized as possible.\n\n\n  for (; i < src.length - 3; i += 4) {\n    // NOTE: codepoint is a signed int32 and can be negative.\n    if (isLE) {\n      codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;\n    } else {\n      codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;\n    }\n\n    offset = _writeCodepoint(dst, offset, codepoint, badChar);\n  } // Keep overflowing bytes.\n\n\n  for (; i < src.length; i++) {\n    overflow.push(src[i]);\n  }\n\n  return dst.slice(0, offset).toString('ucs2');\n};\n\nfunction _writeCodepoint(dst, offset, codepoint, badChar) {\n  // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.\n  if (codepoint < 0 || codepoint > 0x10FFFF) {\n    // Not a valid Unicode codepoint\n    codepoint = badChar;\n  } // Ephemeral Planes: Write high surrogate.\n\n\n  if (codepoint >= 0x10000) {\n    codepoint -= 0x10000;\n    var high = 0xD800 | codepoint >> 10;\n    dst[offset++] = high & 0xff;\n    dst[offset++] = high >> 8; // Low surrogate is written below.\n\n    var codepoint = 0xDC00 | codepoint & 0x3FF;\n  } // Write BMP char or low surrogate.\n\n\n  dst[offset++] = codepoint & 0xff;\n  dst[offset++] = codepoint >> 8;\n  return offset;\n}\n\n;\n\nUtf32Decoder.prototype.end = function () {\n  this.overflow.length = 0;\n}; // == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\n\nexports.utf32 = Utf32AutoCodec;\nexports.ucs4 = 'utf32';\n\nfunction Utf32AutoCodec(options, iconv) {\n  this.iconv = iconv;\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder;\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder; // -- Encoding\n\nfunction Utf32AutoEncoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);\n}\n\nUtf32AutoEncoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\nUtf32AutoEncoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction Utf32AutoDecoder(options, codec) {\n  this.decoder = null;\n  this.initialBufs = [];\n  this.initialBufsLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\nUtf32AutoDecoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBufs.push(buf);\n    this.initialBufsLen += buf.length;\n    if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);\n\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.write(buf);\n};\n\nUtf32AutoDecoder.prototype.end = function () {\n  if (!this.decoder) {\n    var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var resStr = '';\n\n    for (var i = 0; i < this.initialBufs.length; i++) resStr += this.decoder.write(this.initialBufs[i]);\n\n    var trail = this.decoder.end();\n    if (trail) resStr += trail;\n    this.initialBufs.length = this.initialBufsLen = 0;\n    return resStr;\n  }\n\n  return this.decoder.end();\n};\n\nfunction detectEncoding(bufs, defaultEncoding) {\n  var b = [];\n  var charsProcessed = 0;\n  var invalidLE = 0,\n      invalidBE = 0; // Number of invalid chars when decoded as LE or BE.\n\n  var bmpCharsLE = 0,\n      bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.\n\n  outer_loop: for (var i = 0; i < bufs.length; i++) {\n    var buf = bufs[i];\n\n    for (var j = 0; j < buf.length; j++) {\n      b.push(buf[j]);\n\n      if (b.length === 4) {\n        if (charsProcessed === 0) {\n          // Check BOM first.\n          if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {\n            return 'utf-32le';\n          }\n\n          if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {\n            return 'utf-32be';\n          }\n        }\n\n        if (b[0] !== 0 || b[1] > 0x10) invalidBE++;\n        if (b[3] !== 0 || b[2] > 0x10) invalidLE++;\n        if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;\n        if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;\n        b.length = 0;\n        charsProcessed++;\n\n        if (charsProcessed >= 100) {\n          break outer_loop;\n        }\n      }\n    }\n  } // Make decisions.\n\n\n  if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return 'utf-32be';\n  if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return 'utf-32le'; // Couldn't decide (likely all zeros or not enough data).\n\n  return defaultEncoding || 'utf-32le';\n}","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // UTF-7 codec, according to https://tools.ietf.org/html/rfc2152\n// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3\n\n\nexports.utf7 = Utf7Codec;\nexports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7\n\nfunction Utf7Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n}\n\n;\nUtf7Codec.prototype.encoder = Utf7Encoder;\nUtf7Codec.prototype.decoder = Utf7Decoder;\nUtf7Codec.prototype.bomAware = true; // -- Encoding\n\nvar nonDirectChars = /[^A-Za-z0-9'\\(\\),-\\.\\/:\\? \\n\\r\\t]+/g;\n\nfunction Utf7Encoder(options, codec) {\n  this.iconv = codec.iconv;\n}\n\nUtf7Encoder.prototype.write = function (str) {\n  // Naive implementation.\n  // Non-direct chars are encoded as \"+<base64>-\"; single \"+\" char is encoded as \"+-\".\n  return Buffer.from(str.replace(nonDirectChars, function (chunk) {\n    return \"+\" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + \"-\";\n  }.bind(this)));\n};\n\nUtf7Encoder.prototype.end = function () {}; // -- Decoding\n\n\nfunction Utf7Decoder(options, codec) {\n  this.iconv = codec.iconv;\n  this.inBase64 = false;\n  this.base64Accum = '';\n}\n\nvar base64Regex = /[A-Za-z0-9\\/+]/;\nvar base64Chars = [];\n\nfor (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));\n\nvar plusChar = '+'.charCodeAt(0),\n    minusChar = '-'.charCodeAt(0),\n    andChar = '&'.charCodeAt(0);\n\nUtf7Decoder.prototype.write = function (buf) {\n  var res = \"\",\n      lastI = 0,\n      inBase64 = this.inBase64,\n      base64Accum = this.base64Accum; // The decoder is more involved as we must handle chunks in stream.\n\n  for (var i = 0; i < buf.length; i++) {\n    if (!inBase64) {\n      // We're in direct mode.\n      // Write direct chars until '+'\n      if (buf[i] == plusChar) {\n        res += this.iconv.decode(buf.slice(lastI, i), \"ascii\"); // Write direct chars.\n\n        lastI = i + 1;\n        inBase64 = true;\n      }\n    } else {\n      // We decode base64.\n      if (!base64Chars[buf[i]]) {\n        // Base64 ended.\n        if (i == lastI && buf[i] == minusChar) {\n          // \"+-\" -> \"+\"\n          res += \"+\";\n        } else {\n          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), \"ascii\");\n          res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n        }\n\n        if (buf[i] != minusChar) // Minus is absorbed after base64.\n          i--;\n        lastI = i + 1;\n        inBase64 = false;\n        base64Accum = '';\n      }\n    }\n  }\n\n  if (!inBase64) {\n    res += this.iconv.decode(buf.slice(lastI), \"ascii\"); // Write direct chars.\n  } else {\n    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), \"ascii\");\n    var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n\n    base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.\n\n    b64str = b64str.slice(0, canBeDecoded);\n    res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n  }\n\n  this.inBase64 = inBase64;\n  this.base64Accum = base64Accum;\n  return res;\n};\n\nUtf7Decoder.prototype.end = function () {\n  var res = \"\";\n  if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), \"utf16-be\");\n  this.inBase64 = false;\n  this.base64Accum = '';\n  return res;\n}; // UTF-7-IMAP codec.\n// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)\n// Differences:\n//  * Base64 part is started by \"&\" instead of \"+\"\n//  * Direct characters are 0x20-0x7E, except \"&\" (0x26)\n//  * In Base64, \",\" is used instead of \"/\"\n//  * Base64 must not be used to represent direct characters.\n//  * No implicit shift back from Base64 (should always end with '-')\n//  * String must end in non-shifted position.\n//  * \"-&\" while in base64 is not allowed.\n\n\nexports.utf7imap = Utf7IMAPCodec;\n\nfunction Utf7IMAPCodec(codecOptions, iconv) {\n  this.iconv = iconv;\n}\n\n;\nUtf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;\nUtf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;\nUtf7IMAPCodec.prototype.bomAware = true; // -- Encoding\n\nfunction Utf7IMAPEncoder(options, codec) {\n  this.iconv = codec.iconv;\n  this.inBase64 = false;\n  this.base64Accum = Buffer.alloc(6);\n  this.base64AccumIdx = 0;\n}\n\nUtf7IMAPEncoder.prototype.write = function (str) {\n  var inBase64 = this.inBase64,\n      base64Accum = this.base64Accum,\n      base64AccumIdx = this.base64AccumIdx,\n      buf = Buffer.alloc(str.length * 5 + 10),\n      bufIdx = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var uChar = str.charCodeAt(i);\n\n    if (0x20 <= uChar && uChar <= 0x7E) {\n      // Direct character or '&'.\n      if (inBase64) {\n        if (base64AccumIdx > 0) {\n          bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\\//g, ',').replace(/=+$/, ''), bufIdx);\n          base64AccumIdx = 0;\n        }\n\n        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.\n\n        inBase64 = false;\n      }\n\n      if (!inBase64) {\n        buf[bufIdx++] = uChar; // Write direct character\n\n        if (uChar === andChar) // Ampersand -> '&-'\n          buf[bufIdx++] = minusChar;\n      }\n    } else {\n      // Non-direct character\n      if (!inBase64) {\n        buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.\n\n        inBase64 = true;\n      }\n\n      if (inBase64) {\n        base64Accum[base64AccumIdx++] = uChar >> 8;\n        base64Accum[base64AccumIdx++] = uChar & 0xFF;\n\n        if (base64AccumIdx == base64Accum.length) {\n          bufIdx += buf.write(base64Accum.toString('base64').replace(/\\//g, ','), bufIdx);\n          base64AccumIdx = 0;\n        }\n      }\n    }\n  }\n\n  this.inBase64 = inBase64;\n  this.base64AccumIdx = base64AccumIdx;\n  return buf.slice(0, bufIdx);\n};\n\nUtf7IMAPEncoder.prototype.end = function () {\n  var buf = Buffer.alloc(10),\n      bufIdx = 0;\n\n  if (this.inBase64) {\n    if (this.base64AccumIdx > 0) {\n      bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\\//g, ',').replace(/=+$/, ''), bufIdx);\n      this.base64AccumIdx = 0;\n    }\n\n    buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.\n\n    this.inBase64 = false;\n  }\n\n  return buf.slice(0, bufIdx);\n}; // -- Decoding\n\n\nfunction Utf7IMAPDecoder(options, codec) {\n  this.iconv = codec.iconv;\n  this.inBase64 = false;\n  this.base64Accum = '';\n}\n\nvar base64IMAPChars = base64Chars.slice();\nbase64IMAPChars[','.charCodeAt(0)] = true;\n\nUtf7IMAPDecoder.prototype.write = function (buf) {\n  var res = \"\",\n      lastI = 0,\n      inBase64 = this.inBase64,\n      base64Accum = this.base64Accum; // The decoder is more involved as we must handle chunks in stream.\n  // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).\n\n  for (var i = 0; i < buf.length; i++) {\n    if (!inBase64) {\n      // We're in direct mode.\n      // Write direct chars until '&'\n      if (buf[i] == andChar) {\n        res += this.iconv.decode(buf.slice(lastI, i), \"ascii\"); // Write direct chars.\n\n        lastI = i + 1;\n        inBase64 = true;\n      }\n    } else {\n      // We decode base64.\n      if (!base64IMAPChars[buf[i]]) {\n        // Base64 ended.\n        if (i == lastI && buf[i] == minusChar) {\n          // \"&-\" -> \"&\"\n          res += \"&\";\n        } else {\n          var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), \"ascii\").replace(/,/g, '/');\n          res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n        }\n\n        if (buf[i] != minusChar) // Minus may be absorbed after base64.\n          i--;\n        lastI = i + 1;\n        inBase64 = false;\n        base64Accum = '';\n      }\n    }\n  }\n\n  if (!inBase64) {\n    res += this.iconv.decode(buf.slice(lastI), \"ascii\"); // Write direct chars.\n  } else {\n    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), \"ascii\").replace(/,/g, '/');\n    var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.\n\n    base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.\n\n    b64str = b64str.slice(0, canBeDecoded);\n    res += this.iconv.decode(Buffer.from(b64str, 'base64'), \"utf16-be\");\n  }\n\n  this.inBase64 = inBase64;\n  this.base64Accum = base64Accum;\n  return res;\n};\n\nUtf7IMAPDecoder.prototype.end = function () {\n  var res = \"\";\n  if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), \"utf16-be\");\n  this.inBase64 = false;\n  this.base64Accum = '';\n  return res;\n};","\"use strict\";\n\nvar BOMChar = '\\uFEFF';\nexports.PrependBOM = PrependBOMWrapper;\n\nfunction PrependBOMWrapper(encoder, options) {\n  this.encoder = encoder;\n  this.addBOM = true;\n}\n\nPrependBOMWrapper.prototype.write = function (str) {\n  if (this.addBOM) {\n    str = BOMChar + str;\n    this.addBOM = false;\n  }\n\n  return this.encoder.write(str);\n};\n\nPrependBOMWrapper.prototype.end = function () {\n  return this.encoder.end();\n}; //------------------------------------------------------------------------------\n\n\nexports.StripBOM = StripBOMWrapper;\n\nfunction StripBOMWrapper(decoder, options) {\n  this.decoder = decoder;\n  this.pass = false;\n  this.options = options || {};\n}\n\nStripBOMWrapper.prototype.write = function (buf) {\n  var res = this.decoder.write(buf);\n  if (this.pass || !res) return res;\n\n  if (res[0] === BOMChar) {\n    res = res.slice(1);\n    if (typeof this.options.stripBOM === 'function') this.options.stripBOM();\n  }\n\n  this.pass = true;\n  return res;\n};\n\nStripBOMWrapper.prototype.end = function () {\n  return this.decoder.end();\n};","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer;\n\nvar bomHandling = require(\"./bom-handling\"),\n    iconv = module.exports; // All codecs and aliases are kept here, keyed by encoding name/alias.\n// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.\n\n\niconv.encodings = null; // Characters emitted in case of error.\n\niconv.defaultCharUnicode = '';\niconv.defaultCharSingleByte = '?'; // Public API.\n\niconv.encode = function encode(str, encoding, options) {\n  str = \"\" + (str || \"\"); // Ensure string.\n\n  var encoder = iconv.getEncoder(encoding, options);\n  var res = encoder.write(str);\n  var trail = encoder.end();\n  return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;\n};\n\niconv.decode = function decode(buf, encoding, options) {\n  if (typeof buf === 'string') {\n    if (!iconv.skipDecodeWarning) {\n      console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');\n      iconv.skipDecodeWarning = true;\n    }\n\n    buf = Buffer.from(\"\" + (buf || \"\"), \"binary\"); // Ensure buffer.\n  }\n\n  var decoder = iconv.getDecoder(encoding, options);\n  var res = decoder.write(buf);\n  var trail = decoder.end();\n  return trail ? res + trail : res;\n};\n\niconv.encodingExists = function encodingExists(enc) {\n  try {\n    iconv.getCodec(enc);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}; // Legacy aliases to convert functions\n\n\niconv.toEncoding = iconv.encode;\niconv.fromEncoding = iconv.decode; // Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.\n\niconv._codecDataCache = {};\n\niconv.getCodec = function getCodec(encoding) {\n  if (!iconv.encodings) iconv.encodings = require(\"../encodings\"); // Lazy load all encoding definitions.\n  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n\n  var enc = iconv._canonicalizeEncoding(encoding); // Traverse iconv.encodings to find actual codec.\n\n\n  var codecOptions = {};\n\n  while (true) {\n    var codec = iconv._codecDataCache[enc];\n    if (codec) return codec;\n    var codecDef = iconv.encodings[enc];\n\n    switch (typeof codecDef) {\n      case \"string\":\n        // Direct alias to other encoding.\n        enc = codecDef;\n        break;\n\n      case \"object\":\n        // Alias with options. Can be layered.\n        for (var key in codecDef) codecOptions[key] = codecDef[key];\n\n        if (!codecOptions.encodingName) codecOptions.encodingName = enc;\n        enc = codecDef.type;\n        break;\n\n      case \"function\":\n        // Codec itself.\n        if (!codecOptions.encodingName) codecOptions.encodingName = enc; // The codec function must load all tables and return object with .encoder and .decoder methods.\n        // It'll be called only once (for each different options object).\n\n        codec = new codecDef(codecOptions, iconv);\n        iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.\n\n        return codec;\n\n      default:\n        throw new Error(\"Encoding not recognized: '\" + encoding + \"' (searched as: '\" + enc + \"')\");\n    }\n  }\n};\n\niconv._canonicalizeEncoding = function (encoding) {\n  // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.\n  return ('' + encoding).toLowerCase().replace(/:\\d{4}$|[^0-9a-z]/g, \"\");\n};\n\niconv.getEncoder = function getEncoder(encoding, options) {\n  var codec = iconv.getCodec(encoding),\n      encoder = new codec.encoder(options, codec);\n  if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);\n  return encoder;\n};\n\niconv.getDecoder = function getDecoder(encoding, options) {\n  var codec = iconv.getCodec(encoding),\n      decoder = new codec.decoder(options, codec);\n  if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);\n  return decoder;\n}; // Streaming API\n// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add\n// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.\n// If you would like to enable it explicitly, please add the following code to your app:\n// > iconv.enableStreamingAPI(require('stream'));\n\n\niconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {\n  if (iconv.supportsStreams) return; // Dependency-inject stream module to create IconvLite stream classes.\n\n  var streams = require(\"./streams\")(stream_module); // Not public API yet, but expose the stream classes.\n\n\n  iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;\n  iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream; // Streaming API.\n\n  iconv.encodeStream = function encodeStream(encoding, options) {\n    return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);\n  };\n\n  iconv.decodeStream = function decodeStream(encoding, options) {\n    return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);\n  };\n\n  iconv.supportsStreams = true;\n}; // Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).\n\n\nvar stream_module;\n\ntry {\n  stream_module = require(\"stream\");\n} catch (e) {}\n\nif (stream_module && stream_module.Transform) {\n  iconv.enableStreamingAPI(stream_module);\n} else {\n  // In rare cases where 'stream' module is not available by default, throw a helpful exception.\n  iconv.encodeStream = iconv.decodeStream = function () {\n    throw new Error(\"iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.\");\n  };\n}\n\nif (\"\" != \"\\u0100\") {\n  console.error(\"iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.\");\n}","\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), \n// we opt to dependency-inject it instead of creating a hard dependency.\n\n\nmodule.exports = function (stream_module) {\n  var Transform = stream_module.Transform; // == Encoder stream =======================================================\n\n  function IconvLiteEncoderStream(conv, options) {\n    this.conv = conv;\n    options = options || {};\n    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.\n\n    Transform.call(this, options);\n  }\n\n  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: {\n      value: IconvLiteEncoderStream\n    }\n  });\n\n  IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {\n    if (typeof chunk != 'string') return done(new Error(\"Iconv encoding stream needs strings as its input.\"));\n\n    try {\n      var res = this.conv.write(chunk);\n      if (res && res.length) this.push(res);\n      done();\n    } catch (e) {\n      done(e);\n    }\n  };\n\n  IconvLiteEncoderStream.prototype._flush = function (done) {\n    try {\n      var res = this.conv.end();\n      if (res && res.length) this.push(res);\n      done();\n    } catch (e) {\n      done(e);\n    }\n  };\n\n  IconvLiteEncoderStream.prototype.collect = function (cb) {\n    var chunks = [];\n    this.on('error', cb);\n    this.on('data', function (chunk) {\n      chunks.push(chunk);\n    });\n    this.on('end', function () {\n      cb(null, Buffer.concat(chunks));\n    });\n    return this;\n  }; // == Decoder stream =======================================================\n\n\n  function IconvLiteDecoderStream(conv, options) {\n    this.conv = conv;\n    options = options || {};\n    options.encoding = this.encoding = 'utf8'; // We output strings.\n\n    Transform.call(this, options);\n  }\n\n  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {\n    constructor: {\n      value: IconvLiteDecoderStream\n    }\n  });\n\n  IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {\n    if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array)) return done(new Error(\"Iconv decoding stream needs buffers as its input.\"));\n\n    try {\n      var res = this.conv.write(chunk);\n      if (res && res.length) this.push(res, this.encoding);\n      done();\n    } catch (e) {\n      done(e);\n    }\n  };\n\n  IconvLiteDecoderStream.prototype._flush = function (done) {\n    try {\n      var res = this.conv.end();\n      if (res && res.length) this.push(res, this.encoding);\n      done();\n    } catch (e) {\n      done(e);\n    }\n  };\n\n  IconvLiteDecoderStream.prototype.collect = function (cb) {\n    var res = '';\n    this.on('error', cb);\n    this.on('data', function (chunk) {\n      res += chunk;\n    });\n    this.on('end', function () {\n      cb(null, res);\n    });\n    return this;\n  };\n\n  return {\n    IconvLiteEncoderStream: IconvLiteEncoderStream,\n    IconvLiteDecoderStream: IconvLiteDecoderStream\n  };\n};","const FRAME_IDENTIFIERS = {\n  v2: {\n    album: \"TAL\",\n    bpm: \"TBP\",\n    composer: \"TCM\",\n    genre: \"TCO\",\n    copyright: \"TCR\",\n    date: \"TDA\",\n    playlistDelay: \"TDY\",\n    encodedBy: \"TEN\",\n    textWriter: \"TEXT\",\n    fileType: \"TFT\",\n    time: \"TIM\",\n    contentGroup: \"TT1\",\n    title: \"TT2\",\n    subtitle: \"TT3\",\n    initialKey: \"TKE\",\n    language: \"TLA\",\n    length: \"TLE\",\n    mediaType: \"TMT\",\n    originalTitle: \"TOT\",\n    originalFilename: \"TOF\",\n    originalTextwriter: \"TOL\",\n    originalArtist: \"TOA\",\n    originalYear: \"TOR\",\n    artist: \"TP1\",\n    performerInfo: \"TP2\",\n    conductor: \"TP3\",\n    remixArtist: \"TP4\",\n    partOfSet: \"TPA\",\n    publisher: \"TPB\",\n    trackNumber: \"TRK\",\n    recordingDates: \"TRD\",\n    size: \"TSI\",\n    ISRC: \"TRC\",\n    encodingTechnology: \"TSS\",\n    year: \"TYE\",\n    image: \"PIC\",\n    commercialUrl: \"WCM\",\n    copyrightUrl: \"WCP\",\n    fileUrl: \"WAF\",\n    artistUrl: \"WAR\",\n    audioSourceUrl: \"WAS\",\n    publisherUrl: \"WPB\",\n    userDefinedUrl: \"WXX\"\n  },\n  v3: {\n    album: \"TALB\",\n    bpm: \"TBPM\",\n    composer: \"TCOM\",\n    genre: \"TCON\",\n    copyright: \"TCOP\",\n    date: \"TDAT\",\n    playlistDelay: \"TDLY\",\n    encodedBy: \"TENC\",\n    textWriter: \"TEXT\",\n    fileType: \"TFLT\",\n    time: \"TIME\",\n    contentGroup: \"TIT1\",\n    title: \"TIT2\",\n    subtitle: \"TIT3\",\n    initialKey: \"TKEY\",\n    language: \"TLAN\",\n    length: \"TLEN\",\n    mediaType: \"TMED\",\n    originalTitle: \"TOAL\",\n    originalFilename: \"TOFN\",\n    originalTextwriter: \"TOLY\",\n    originalArtist: \"TOPE\",\n    originalYear: \"TORY\",\n    fileOwner: \"TOWN\",\n    artist: \"TPE1\",\n    performerInfo: \"TPE2\",\n    conductor: \"TPE3\",\n    remixArtist: \"TPE4\",\n    partOfSet: \"TPOS\",\n    publisher: \"TPUB\",\n    trackNumber: \"TRCK\",\n    recordingDates: \"TRDA\",\n    internetRadioName: \"TRSN\",\n    internetRadioOwner: \"TRSO\",\n    size: \"TSIZ\",\n    ISRC: \"TSRC\",\n    encodingTechnology: \"TSSE\",\n    year: \"TYER\",\n    comment: \"COMM\",\n    image: \"APIC\",\n    unsynchronisedLyrics: \"USLT\",\n    userDefinedText: \"TXXX\",\n    popularimeter: \"POPM\",\n    private: \"PRIV\",\n    chapter: \"CHAP\",\n    tableOfContents: \"CTOC\",\n    userDefinedUrl: \"WXXX\",\n    commercialUrl: \"WCOM\",\n    copyrightUrl: \"WCOP\",\n    fileUrl: \"WOAF\",\n    artistUrl: \"WOAR\",\n    audioSourceUrl: \"WOAS\",\n    radioStationUrl: \"WORS\",\n    paymentUrl: \"WPAY\",\n    publisherUrl: \"WPUB\"\n  }\n};\nconst FRAME_INTERNAL_IDENTIFIERS = {\n  v2: Object.keys(FRAME_IDENTIFIERS.v2).reduce((acc, key) => {\n    acc[FRAME_IDENTIFIERS.v2[key]] = key;\n    return acc;\n  }, {}),\n  v3: Object.keys(FRAME_IDENTIFIERS.v3).reduce((acc, key) => {\n    acc[FRAME_IDENTIFIERS.v3[key]] = key;\n    return acc;\n  }, {})\n};\nconst ID3_FRAME_OPTIONS = {\n  v2: {\n    \"PIC\": {\n      multiple: false\n      /* change in 1.0 */\n\n    },\n    \"WCM\": {\n      multiple: true\n    },\n    \"WAR\": {\n      multiple: true\n    }\n  },\n  v3: {\n    \"T___\": {\n      multiple: false\n    },\n    \"TXXX\": {\n      multiple: true,\n      updateCompareKey: \"description\"\n    },\n    \"APIC\": {\n      multiple: false\n      /* change in 1.0 */\n\n    },\n    \"USLT\": {\n      multiple: false\n    },\n    \"COMM\": {\n      multiple: false\n      /* change in 1.0 */\n\n    },\n    \"POPM\": {\n      multiple: false\n      /* change in 1.0 */\n\n    },\n    \"PRIV\": {\n      multiple: true\n    },\n    \"CTOC\": {\n      multiple: true\n    },\n    \"CHAP\": {\n      multiple: true\n    },\n    \"WXXX\": {\n      multiple: true,\n      updateCompareKey: \"description\"\n    },\n    \"WCOM\": {\n      multiple: true\n    },\n    \"WOAR\": {\n      multiple: true\n    }\n  }\n};\n/*\r\n**  List of official text information frames\r\n**  LibraryName: \"T***\"\r\n**  Value is the ID of the text frame specified in the link above, the object's keys are just for simplicity, you can also use the ID directly.\r\n*/\n\n/*\r\n**  Officially available types of the picture frame\r\n*/\n\nconst APICTypes = [\"other\", \"file icon\", \"other file icon\", \"front cover\", \"back cover\", \"leaflet page\", \"media\", \"lead artist\", \"artist\", \"conductor\", \"band\", \"composer\", \"lyricist\", \"recording location\", \"during recording\", \"during performance\", \"video screen capture\", \"a bright coloured fish\", \"illustration\", \"band logotype\", \"publisher logotype\"];\nconst ENCODINGS = ['ISO-8859-1', 'UTF-16', 'UTF-16BE', 'utf8'];\nmodule.exports.APIC_TYPES = APICTypes;\nmodule.exports.ENCODINGS = ENCODINGS;\nmodule.exports.FRAME_IDENTIFIERS = FRAME_IDENTIFIERS;\nmodule.exports.FRAME_INTERNAL_IDENTIFIERS = FRAME_INTERNAL_IDENTIFIERS;\nmodule.exports.ID3_FRAME_OPTIONS = ID3_FRAME_OPTIONS;","module.exports = ID3FrameBuilder;\n\nconst ID3Util = require('./ID3Util');\n\nfunction ID3FrameBuilder(identifier) {\n  this._identifier = identifier;\n  this._buffer = Buffer.alloc(0);\n}\n\nID3FrameBuilder.prototype.appendStaticValue = function (value, size, encoding = 0x00) {\n  const convertedValue = convertValue(value, encoding);\n  this._buffer = Buffer.concat([this._buffer, staticValueToBuffer(convertedValue, size)]);\n  return this;\n};\n\nID3FrameBuilder.prototype.appendStaticNumber = function (value, size) {\n  if (Number.isInteger(value)) {\n    let hexValue = value.toString(16);\n\n    if (hexValue.length % 2 !== 0) {\n      hexValue = \"0\" + hexValue;\n    }\n\n    this._buffer = Buffer.concat([this._buffer, staticValueToBuffer(Buffer.from(hexValue, 'hex'), size)]);\n  }\n\n  return this;\n};\n\nID3FrameBuilder.prototype.appendNullTerminatedValue = function (value, encoding = 0x00) {\n  if (!value) value = '';\n  const convertedValue = convertValue(value, encoding);\n  this._buffer = Buffer.concat([this._buffer, nullTerminatedValueToBuffer(convertedValue, encoding)]);\n  return this;\n};\n\nID3FrameBuilder.prototype.getBuffer = function () {\n  const header = Buffer.alloc(10);\n  header.write(this._identifier, 0);\n  header.writeUInt32BE(this._buffer.length, 4);\n  return Buffer.concat([header, this._buffer]);\n};\n\nfunction convertValue(value, encoding = 0x00) {\n  if (value instanceof Buffer) {\n    return value;\n  } else if (Number.isInteger(value)) {\n    return ID3Util.stringToEncodedBuffer(value.toString(), encoding);\n  } else if (typeof value === 'string' || value instanceof String) {\n    return ID3Util.stringToEncodedBuffer(value, encoding);\n  } else {\n    return Buffer.alloc(0);\n  }\n}\n\nfunction staticValueToBuffer(buffer, size) {\n  if (!(buffer instanceof Buffer)) return Buffer.alloc(0);\n\n  if (size && buffer.length < size) {\n    return Buffer.concat([Buffer.alloc(size - buffer.length, 0x00), buffer]);\n  } else {\n    return buffer;\n  }\n}\n\nfunction nullTerminatedValueToBuffer(buffer, encoding) {\n  return Buffer.concat([buffer, ID3Util.terminationBuffer(encoding)]);\n}","module.exports = ID3FrameReader;\n\nconst ID3Util = require('./ID3Util');\n\nfunction ID3FrameReader(buffer, encodingBytePosition, consumeEncodingByte = true) {\n  if (!buffer || !(buffer instanceof Buffer)) buffer = Buffer.alloc(0);\n\n  if (Number.isInteger(encodingBytePosition)) {\n    this._encoding = buffer[encodingBytePosition] ? buffer[encodingBytePosition] : 0x00;\n\n    if (consumeEncodingByte) {\n      buffer = encodingBytePosition === 0 ? buffer.slice(1) : Buffer.concat([buffer.slice(0, encodingBytePosition), buffer.slice(encodingBytePosition)]);\n    }\n  } else {\n    this._encoding = 0x00;\n  }\n\n  this._splitBuffer = new ID3Util.SplitBuffer(null, buffer.slice(0));\n}\n\nID3FrameReader.prototype.consumeStaticValue = function (dataType, size, encoding = this._encoding) {\n  return this._consumeByFunction(() => staticValueFromBuffer(this._splitBuffer.remainder, size), dataType, encoding);\n};\n\nID3FrameReader.prototype.consumeNullTerminatedValue = function (dataType, encoding = this._encoding) {\n  return this._consumeByFunction(() => nullTerminatedValueFromBuffer(this._splitBuffer.remainder, encoding), dataType, encoding);\n};\n\nID3FrameReader.prototype._consumeByFunction = function (fn, dataType, encoding) {\n  if (!this._splitBuffer.remainder || this._splitBuffer.remainder.length === 0) {\n    return undefined;\n  }\n\n  this._splitBuffer = fn();\n\n  if (dataType) {\n    return convertValue(this._splitBuffer.value, dataType, encoding);\n  } else {\n    return this._splitBuffer.value;\n  }\n};\n\nfunction convertValue(buffer, dataType, encoding = 0x00) {\n  if (!buffer) return undefined;\n  if (!(buffer instanceof Buffer)) return buffer;\n  if (buffer.length === 0) return undefined;\n\n  if (dataType === \"number\") {\n    return parseInt(buffer.toString('hex'), 16);\n  } else if (dataType === \"string\") {\n    return ID3Util.bufferToDecodedString(buffer, encoding);\n  } else {\n    return buffer;\n  }\n}\n\nfunction staticValueFromBuffer(buffer, size) {\n  if (size === undefined || size === null) {\n    size = buffer.length;\n  }\n\n  if (buffer.length > size) {\n    return new ID3Util.SplitBuffer(buffer.slice(0, size), buffer.slice(size));\n  } else {\n    return new ID3Util.SplitBuffer(buffer.slice(0), null);\n  }\n}\n\nfunction nullTerminatedValueFromBuffer(buffer, encoding = 0x00) {\n  return ID3Util.splitNullTerminatedBuffer(buffer, encoding);\n}","const fs = require('fs');\n\nconst ID3FrameBuilder = require(\"./ID3FrameBuilder\");\n\nconst ID3FrameReader = require(\"./ID3FrameReader\");\n\nconst ID3Definitions = require(\"./ID3Definitions\");\n\nmodule.exports.GENERIC_TEXT = {\n  create: (specName, data) => {\n    if (!specName || !data) {\n      return null;\n    }\n\n    return new ID3FrameBuilder(specName).appendStaticNumber(0x01, 0x01).appendStaticValue(data, null, 0x01).getBuffer();\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer, 0);\n    return reader.consumeStaticValue('string');\n  }\n};\nmodule.exports.GENERIC_URL = {\n  create: (specName, data) => {\n    if (!specName || !data) {\n      return null;\n    }\n\n    return new ID3FrameBuilder(specName).appendStaticValue(data).getBuffer();\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer);\n    return reader.consumeStaticValue('string');\n  }\n};\nmodule.exports.APIC = {\n  create: data => {\n    try {\n      if (data instanceof Buffer) {\n        data = {\n          imageBuffer: Buffer.from(data)\n        };\n      } else if (typeof data === 'string' || data instanceof String) {\n        data = {\n          imageBuffer: fs.readFileSync(data)\n        };\n      } else if (!data.imageBuffer) {\n        return Buffer.alloc(0);\n      }\n\n      let mime_type = data.mime;\n\n      if (!data.mime) {\n        if (data.imageBuffer.length > 3 && data.imageBuffer.compare(Buffer.from([0xff, 0xd8, 0xff]), 0, 3, 0, 3) === 0) {\n          mime_type = \"image/jpeg\";\n        } else if (data.imageBuffer.length > 8 && data.imageBuffer.compare(Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]), 0, 8, 0, 8) === 0) {\n          mime_type = \"image/png\";\n        } else {\n          mime_type = \"\";\n        }\n      }\n      /*\r\n       * Fix a bug in iTunes where the artwork is not recognized when the description is empty using UTF-16.\r\n       * Instead, if the description is empty, use encoding 0x00 (ISO-8859-1).\r\n       */\n\n\n      const {\n        description = ''\n      } = data;\n      const encoding = description ? 0x01 : 0x00;\n      return new ID3FrameBuilder(\"APIC\").appendStaticNumber(encoding, 1).appendNullTerminatedValue(mime_type).appendStaticNumber(0x03, 1).appendNullTerminatedValue(description, encoding).appendStaticValue(data.imageBuffer).getBuffer();\n    } catch (e) {\n      return e;\n    }\n  },\n  read: (buffer, version) => {\n    const reader = new ID3FrameReader(buffer, 0);\n    let mime;\n\n    if (version === 2) {\n      mime = reader.consumeStaticValue('string', 3, 0x00);\n    } else {\n      mime = reader.consumeNullTerminatedValue('string', 0x00);\n    }\n\n    const typeId = reader.consumeStaticValue('number', 1);\n    const description = reader.consumeNullTerminatedValue('string');\n    const imageBuffer = reader.consumeStaticValue();\n    return {\n      mime: mime,\n      type: {\n        id: typeId,\n        name: ID3Definitions.APIC_TYPES[typeId]\n      },\n      description: description,\n      imageBuffer: imageBuffer\n    };\n  }\n};\nmodule.exports.COMM = {\n  create: data => {\n    data = data || {};\n\n    if (!data.text) {\n      return null;\n    }\n\n    return new ID3FrameBuilder(\"COMM\").appendStaticNumber(0x01, 1).appendStaticValue(data.language).appendNullTerminatedValue(data.shortText, 0x01).appendStaticValue(data.text, null, 0x01).getBuffer();\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer, 0);\n    return {\n      language: reader.consumeStaticValue('string', 3, 0x00),\n      shortText: reader.consumeNullTerminatedValue('string'),\n      text: reader.consumeStaticValue('string', null)\n    };\n  }\n};\nmodule.exports.USLT = {\n  create: data => {\n    data = data || {};\n\n    if (typeof data === 'string' || data instanceof String) {\n      data = {\n        text: data\n      };\n    }\n\n    if (!data.text) {\n      return null;\n    }\n\n    return new ID3FrameBuilder(\"USLT\").appendStaticNumber(0x01, 1).appendStaticValue(data.language).appendNullTerminatedValue(data.shortText, 0x01).appendStaticValue(data.text, null, 0x01).getBuffer();\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer, 0);\n    return {\n      language: reader.consumeStaticValue('string', 3, 0x00),\n      shortText: reader.consumeNullTerminatedValue('string'),\n      text: reader.consumeStaticValue('string', null)\n    };\n  }\n};\nmodule.exports.TXXX = {\n  create: data => {\n    if (!(data instanceof Array)) {\n      data = [data];\n    }\n\n    return Buffer.concat(data.map(udt => new ID3FrameBuilder(\"TXXX\").appendStaticNumber(0x01, 1).appendNullTerminatedValue(udt.description, 0x01).appendStaticValue(udt.value, null, 0x01).getBuffer()));\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer, 0);\n    return {\n      description: reader.consumeNullTerminatedValue('string'),\n      value: reader.consumeStaticValue('string')\n    };\n  }\n};\nmodule.exports.POPM = {\n  create: data => {\n    const email = data.email;\n    let rating = Math.trunc(data.rating);\n    let counter = Math.trunc(data.counter);\n\n    if (!email) {\n      return null;\n    }\n\n    if (isNaN(rating) || rating < 0 || rating > 255) {\n      rating = 0;\n    }\n\n    if (isNaN(counter) || counter < 0) {\n      counter = 0;\n    }\n\n    return new ID3FrameBuilder(\"POPM\").appendNullTerminatedValue(email).appendStaticNumber(rating, 1).appendStaticNumber(counter, 4).getBuffer();\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer);\n    return {\n      email: reader.consumeNullTerminatedValue('string'),\n      rating: reader.consumeStaticValue('number', 1),\n      counter: reader.consumeStaticValue('number')\n    };\n  }\n};\nmodule.exports.PRIV = {\n  create: data => {\n    if (!(data instanceof Array)) {\n      data = [data];\n    }\n\n    return Buffer.concat(data.map(priv => new ID3FrameBuilder(\"PRIV\").appendNullTerminatedValue(priv.ownerIdentifier).appendStaticValue(priv.data instanceof Buffer ? priv.data : Buffer.from(priv.data, \"utf8\")).getBuffer()));\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer);\n    return {\n      ownerIdentifier: reader.consumeNullTerminatedValue('string'),\n      data: reader.consumeStaticValue()\n    };\n  }\n};\nmodule.exports.CHAP = {\n  create: (data, version, nodeId3) => {\n    if (!(data instanceof Array)) {\n      data = [data];\n    }\n\n    return Buffer.concat(data.map(chap => {\n      if (!chap || !chap.elementID || typeof chap.startTimeMs === \"undefined\" || !chap.endTimeMs) {\n        return null;\n      }\n\n      return new ID3FrameBuilder(\"CHAP\").appendNullTerminatedValue(chap.elementID).appendStaticNumber(chap.startTimeMs, 4).appendStaticNumber(chap.endTimeMs, 4).appendStaticNumber(chap.startOffsetBytes ? chap.startOffsetBytes : 0xFFFFFFFF, 4).appendStaticNumber(chap.endOffsetBytes ? chap.endOffsetBytes : 0xFFFFFFFF, 4).appendStaticValue(nodeId3.create(chap.tags).slice(10)).getBuffer();\n    }).filter(chap => chap instanceof Buffer));\n  },\n  read: (buffer, version, nodeId3) => {\n    const reader = new ID3FrameReader(buffer);\n    let chap = {\n      elementID: reader.consumeNullTerminatedValue('string'),\n      startTimeMs: reader.consumeStaticValue('number', 4),\n      endTimeMs: reader.consumeStaticValue('number', 4),\n      startOffsetBytes: reader.consumeStaticValue('number', 4),\n      endOffsetBytes: reader.consumeStaticValue('number', 4),\n      tags: nodeId3.getTagsFromFrames(nodeId3.getFramesFromID3Body(reader.consumeStaticValue(), 3, 4, 10), 3)\n    };\n    if (chap.startOffsetBytes === 0xFFFFFFFF) delete chap.startOffsetBytes;\n    if (chap.endOffsetBytes === 0xFFFFFFFF) delete chap.endOffsetBytes;\n    return chap;\n  }\n};\nmodule.exports.CTOC = {\n  create: (data, version, nodeId3) => {\n    if (!(data instanceof Array)) {\n      data = [data];\n    }\n\n    return Buffer.concat(data.map((toc, index) => {\n      if (!toc || !toc.elementID) {\n        return null;\n      }\n\n      if (!(toc.elements instanceof Array)) {\n        toc.elements = [];\n      }\n\n      let ctocFlags = Buffer.alloc(1, 0);\n\n      if (index === 0) {\n        ctocFlags[0] += 2;\n      }\n\n      if (toc.isOrdered) {\n        ctocFlags[0] += 1;\n      }\n\n      const builder = new ID3FrameBuilder(\"CTOC\").appendNullTerminatedValue(toc.elementID).appendStaticValue(ctocFlags, 1).appendStaticNumber(toc.elements.length, 1);\n      toc.elements.forEach(el => {\n        builder.appendNullTerminatedValue(el);\n      });\n\n      if (toc.tags) {\n        builder.appendStaticValue(nodeId3.create(toc.tags).slice(10));\n      }\n\n      return builder.getBuffer();\n    }).filter(toc => toc instanceof Buffer));\n  },\n  read: (buffer, version, nodeId3) => {\n    const reader = new ID3FrameReader(buffer);\n    const elementID = reader.consumeNullTerminatedValue('string');\n    const flags = reader.consumeStaticValue('number', 1);\n    const entries = reader.consumeStaticValue('number', 1);\n    const elements = [];\n\n    for (let i = 0; i < entries; i++) {\n      elements.push(reader.consumeNullTerminatedValue('string'));\n    }\n\n    const tags = nodeId3.getTagsFromFrames(nodeId3.getFramesFromID3Body(reader.consumeStaticValue(), 3, 4, 10), 3);\n    return {\n      elementID,\n      isOrdered: !!(flags & 0x01 === 0x01),\n      elements,\n      tags\n    };\n  }\n};\nmodule.exports.WXXX = {\n  create: data => {\n    if (!(data instanceof Array)) {\n      data = [data];\n    }\n\n    return Buffer.concat(data.map(udu => {\n      return new ID3FrameBuilder(\"WXXX\").appendStaticNumber(0x01, 1).appendNullTerminatedValue(udu.description, 0x01).appendStaticValue(udu.url, null).getBuffer();\n    }));\n  },\n  read: buffer => {\n    const reader = new ID3FrameReader(buffer, 0);\n    return {\n      description: reader.consumeNullTerminatedValue('string'),\n      url: reader.consumeStaticValue('string', null, 0x00)\n    };\n  }\n};","const iconv = require('iconv-lite');\n\nconst ID3Definitions = require('./ID3Definitions');\n\nconst ENCODINGS = ['ISO-8859-1', 'UTF-16', 'UTF-16BE', 'UTF-8'];\nmodule.exports.SplitBuffer = class SplitBuffer {\n  constructor(value = null, remainder = null) {\n    this.value = value;\n    this.remainder = remainder;\n  }\n\n};\n\nmodule.exports.splitNullTerminatedBuffer = function (buffer, encodingByte = 0x00) {\n  let termination = {\n    start: -1,\n    size: 0\n  };\n\n  if (encodingByte === 0x01 || encodingByte === 0x02) {\n    termination.start = buffer.indexOf(Buffer.from([0x00, 0x00]));\n    termination.size = 2;\n\n    if (termination.start !== -1 && buffer.length > termination.start + termination.size) {\n      if (buffer[termination.start + termination.size] === 0x00) {\n        termination.start += 1;\n      }\n    }\n  } else {\n    termination.start = buffer.indexOf(0x00);\n    termination.size = 1;\n  }\n\n  if (termination.start === -1) {\n    return new this.SplitBuffer(null, buffer.slice(0));\n  } else if (buffer.length <= termination.start + termination.length) {\n    return new this.SplitBuffer(buffer.slice(0, termination.start), null);\n  } else {\n    return new this.SplitBuffer(buffer.slice(0, termination.start), buffer.slice(termination.start + termination.size));\n  }\n};\n\nmodule.exports.terminationBuffer = function (encodingByte = 0x00) {\n  if (encodingByte === 0x01 || encodingByte === 0x02) {\n    return Buffer.alloc(2, 0x00);\n  } else {\n    return Buffer.alloc(1, 0x00);\n  }\n};\n\nmodule.exports.encodingFromStringOrByte = function (encoding) {\n  if (ENCODINGS.indexOf(encoding) !== -1) {\n    return encoding;\n  } else if (encoding > -1 && encoding < ENCODINGS.length) {\n    encoding = ENCODINGS[encoding];\n  } else {\n    encoding = ENCODINGS[0];\n  }\n\n  return encoding;\n};\n\nmodule.exports.stringToEncodedBuffer = function (str, encodingByte) {\n  return iconv.encode(str, this.encodingFromStringOrByte(encodingByte));\n};\n\nmodule.exports.bufferToDecodedString = function (buffer, encodingByte) {\n  return iconv.decode(buffer, this.encodingFromStringOrByte(encodingByte)).replace(/\\0/g, '');\n};\n\nmodule.exports.getSpecOptions = function (specName, version) {\n  if (version === 2) {\n    if (ID3Definitions.ID3_FRAME_OPTIONS.v2[specName] && ID3Definitions.ID3_FRAME_OPTIONS.v2[specName]) {\n      return ID3Definitions.ID3_FRAME_OPTIONS.v2[specName];\n    }\n  } else if (version === 3 || version === 4) {\n    if (ID3Definitions.ID3_FRAME_OPTIONS.v3[specName] && ID3Definitions.ID3_FRAME_OPTIONS.v3[specName]) {\n      return ID3Definitions.ID3_FRAME_OPTIONS.v3[specName];\n    }\n  }\n\n  return {};\n};\n\nmodule.exports.isValidID3Header = function (buffer) {\n  if (buffer.length < 10) {\n    return false;\n  } else if (buffer.readUIntBE(0, 3) !== 0x494433) {\n    return false;\n  } else if ([0x02, 0x03, 0x04].indexOf(buffer[3]) === -1 || buffer[4] !== 0x00) {\n    return false;\n  } else if (buffer[6] & 128 === 1 || buffer[7] & 128 === 1 || buffer[8] & 128 === 1 || buffer[9] & 128 === 1) {\n    return false;\n  }\n\n  return true;\n};\n\nmodule.exports.getFramePosition = function (buffer) {\n  /* Search Buffer for valid ID3 frame */\n  let framePosition = -1;\n  let frameHeaderValid = false;\n\n  do {\n    framePosition = buffer.indexOf(\"ID3\", framePosition + 1);\n\n    if (framePosition !== -1) {\n      /* It's possible that there is a \"ID3\" sequence without being an ID3 Frame,\r\n       * so we need to check for validity of the next 10 bytes\r\n       */\n      frameHeaderValid = this.isValidID3Header(buffer.slice(framePosition, framePosition + 10));\n    }\n  } while (framePosition !== -1 && !frameHeaderValid);\n\n  if (!frameHeaderValid) {\n    return -1;\n  } else {\n    return framePosition;\n  }\n};\n/**\r\n * @return {Buffer}\r\n */\n\n\nmodule.exports.encodeSize = function (totalSize) {\n  let byte_3 = totalSize & 0x7F;\n  let byte_2 = totalSize >> 7 & 0x7F;\n  let byte_1 = totalSize >> 14 & 0x7F;\n  let byte_0 = totalSize >> 21 & 0x7F;\n  return Buffer.from([byte_0, byte_1, byte_2, byte_3]);\n};\n/**\r\n * @return {Buffer}\r\n */\n\n\nmodule.exports.decodeSize = function (hSize) {\n  return (hSize[0] << 21) + (hSize[1] << 14) + (hSize[2] << 7) + hSize[3];\n};\n\nmodule.exports.getFrameSize = function (buffer, decode, ID3Version) {\n  let decodeBytes;\n\n  if (ID3Version > 2) {\n    decodeBytes = [buffer[4], buffer[5], buffer[6], buffer[7]];\n  } else {\n    decodeBytes = [buffer[3], buffer[4], buffer[5]];\n  }\n\n  if (decode) {\n    return this.decodeSize(Buffer.from(decodeBytes));\n  } else {\n    return Buffer.from(decodeBytes).readUIntBE(0, decodeBytes.length);\n  }\n};\n\nmodule.exports.parseTagHeaderFlags = function (header) {\n  if (!(header instanceof Buffer && header.length >= 10)) {\n    return {};\n  }\n\n  const version = header[3];\n  const flagsByte = header[5];\n\n  if (version === 3) {\n    return {\n      unsynchronisation: !!(flagsByte & 128),\n      extendedHeader: !!(flagsByte & 64),\n      experimentalIndicator: !!(flagsByte & 32)\n    };\n  }\n\n  if (version === 4) {\n    return {\n      unsynchronisation: !!(flagsByte & 128),\n      extendedHeader: !!(flagsByte & 64),\n      experimentalIndicator: !!(flagsByte & 32),\n      footerPresent: !!(flagsByte & 16)\n    };\n  }\n\n  return {};\n};\n\nmodule.exports.parseFrameHeaderFlags = function (header, ID3Version) {\n  if (!(header instanceof Buffer && header.length === 10)) {\n    return {};\n  }\n\n  const flagsFirstByte = header[8];\n  const flagsSecondByte = header[9];\n\n  if (ID3Version === 3) {\n    return {\n      tagAlterPreservation: !!(flagsFirstByte & 128),\n      fileAlterPreservation: !!(flagsFirstByte & 64),\n      readOnly: !!(flagsFirstByte & 32),\n      compression: !!(flagsSecondByte & 128),\n      encryption: !!(flagsSecondByte & 64),\n      groupingIdentity: !!(flagsSecondByte & 32)\n    };\n  }\n\n  if (ID3Version === 4) {\n    return {\n      tagAlterPreservation: !!(flagsFirstByte & 64),\n      fileAlterPreservation: !!(flagsFirstByte & 32),\n      readOnly: !!(flagsFirstByte & 16),\n      groupingIdentity: !!(flagsSecondByte & 64),\n      compression: !!(flagsSecondByte & 8),\n      encryption: !!(flagsSecondByte & 4),\n      unsynchronisation: !!(flagsSecondByte & 2),\n      dataLengthIndicator: !!(flagsSecondByte & 1)\n    };\n  }\n\n  return {};\n};\n\nmodule.exports.processUnsynchronisedBuffer = function (buffer) {\n  const newDataArr = [];\n\n  if (buffer.length > 0) {\n    newDataArr.push(buffer[0]);\n  }\n\n  for (let i = 1; i < buffer.length; i++) {\n    if (buffer[i - 1] === 0xFF && buffer[i] === 0x00) continue;\n    newDataArr.push(buffer[i]);\n  }\n\n  return Buffer.from(newDataArr);\n};","var wrappy = require('wrappy');\n\nmodule.exports = wrappy(once);\nmodule.exports.strict = wrappy(onceStrict);\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this);\n    },\n    configurable: true\n  });\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this);\n    },\n    configurable: true\n  });\n});\n\nfunction once(fn) {\n  var f = function () {\n    if (f.called) return f.value;\n    f.called = true;\n    return f.value = fn.apply(this, arguments);\n  };\n\n  f.called = false;\n  return f;\n}\n\nfunction onceStrict(fn) {\n  var f = function () {\n    if (f.called) throw new Error(f.onceError);\n    f.called = true;\n    return f.value = fn.apply(this, arguments);\n  };\n\n  var name = fn.name || 'Function wrapped with `once`';\n  f.onceError = name + \" shouldn't be called more than once\";\n  f.called = false;\n  return f;\n}","/* eslint-disable node/no-deprecated-api */\n'use strict';\n\nvar buffer = require('buffer');\n\nvar Buffer = buffer.Buffer;\nvar safer = {};\nvar key;\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue;\n  if (key === 'SlowBuffer' || key === 'Buffer') continue;\n  safer[key] = buffer[key];\n}\n\nvar Safer = safer.Buffer = {};\n\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue;\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;\n  Safer[key] = Buffer[key];\n}\n\nsafer.Buffer.prototype = Buffer.prototype;\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value);\n    }\n\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value);\n    }\n\n    return Buffer(value, encodingOrOffset, length);\n  };\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size);\n    }\n\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n\n    var buf = Buffer(size);\n\n    if (!fill || fill.length === 0) {\n      buf.fill(0);\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n\n    return buf;\n  };\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;\n  } catch (e) {// we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  };\n\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;\n  }\n}\n\nmodule.exports = safer;","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as NIL } from './nil.js';\nexport { default as version } from './version.js';\nexport { default as validate } from './validate.js';\nexport { default as stringify } from './stringify.js';\nexport { default as parse } from './parse.js';","import crypto from 'crypto';\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('md5').update(bytes).digest();\n}\n\nexport default md5;","export default '00000000-0000-0000-0000-000000000000';","import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import crypto from 'crypto';\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('sha1').update(bytes).digest();\n}\n\nexport default sha1;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;","import stringify from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n\nfunction version(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nexport default version;","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy;\n\nfunction wrappy(fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb);\n  if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k];\n  });\n  return wrapper;\n\n  function wrapper() {\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    var ret = fn.apply(this, args);\n    var cb = args[args.length - 1];\n\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k];\n      });\n    }\n\n    return ret;\n  }\n}","import * as fs from \"fs\";\nimport { glob } from \"glob\";\nimport NodeID3 from \"node-id3\";\nimport { trackMeta } from \"../../interfaces/index\";\nimport { v4 as uuidv4 } from \"uuid\";\n\n// Using Glob to fetch the files from the Directory\nconst fetchFilesData = async (data: string) => {\n  const scanSelectedFiles = (data: string) => {\n    return new Promise<string[]>((resolve, reject) => {\n      glob(`${data}/**/*.{m4a,mp3}`, (err: Error, files: string[]) => {\n        resolve(files);\n      });\n    });\n  };\n  const result: string[] = await scanSelectedFiles(data);\n  return result;\n};\n\n// Checks if the path is a Directory\nexport const isDirectory = (fileNames: string[]): boolean => {\n  let check: boolean = false;\n  for (let file of fileNames) {\n    let checkStatus = fs.lstatSync(file).isDirectory() === false ? false : true;\n    if (checkStatus === false) return;\n    check = checkStatus;\n  }\n  return check;\n};\n\n// Lets get the meta-tags with Nodeid-3\nconst nodeIDScan = async (path: string) => {\n  const nodeScan = await NodeID3.read(path, { noRaw: false });\n  return nodeScan;\n};\n\n// convert the object to have all attributes\nfunction trackConversion(\n  data: any,\n  fileName: string,\n  fileSize: string\n): trackMeta {\n  return {\n    id: uuidv4(),\n    size: data.size ? data.size : fileSize,\n    filename: fileName,\n    title: data.title ? data.title : \"\",\n    artist: data.artist ? data.artist : \"\",\n    bpm: data.bpm ? data.bpm : \"\",\n    remixArtist: data.remixArtist ? data.remixArtist : \"\",\n    composer: data.composer ? data.composer : \"\",\n    contentGroup: data.contentGroup ? data.contentGroup : \"\",\n    initialKey: data.initialKey ? data.initialKey : \"\",\n    label: data.publisher ? data.publisher : \"\",\n    year: data.year ? data.year : \"\",\n    genre: data.genre ? data.genre : \"default genre\",\n    comment: {\n      text: data.comment?.text ? data.comment?.text : \"default comment\",\n    },\n  };\n}\n\n// grabbing the files, converting,\nexport const getMetaData = async (dir: string) => {\n  const fetchFiles = await fetchFilesData(dir);\n  let newFiles: trackMeta[] = [];\n\n  for (let fileName of fetchFiles) {\n    const stats = fs.statSync(fileName);\n    const filesSizeInBytes = `${stats.size / (1024 * 1000)}MB`;\n    const audioTags = await nodeIDScan(fileName);\n    const convertedTags = trackConversion(\n      audioTags,\n      fileName,\n      filesSizeInBytes\n    );\n    newFiles.push(convertedTags);\n  }\n  return newFiles;\n};\n\n// export const saveFileToJson = (path: string, data: trackMeta[]) => {\n//   try {\n//     const fd = fs.openSync(path, \"w+\");\n//     fs.writeFileSync(fd, JSON.stringify(data, null, 2));\n//     // Setting timeout\n//     setTimeout(function () {\n//       // Its printed after the file is closed\n//       console.log(\"closing file now\");\n\n//       // closing file descriptor\n//       fs.closeSync(fd);\n//     }, 10000);\n//     console.log(\"Program done!\");\n//   } catch (error) {\n//     console.log(\"error: \", error);\n//   }\n// };\n\nmodule.exports = {\n  isDirectory,\n  getMetaData,\n};\n\n// https://dmitripavlutin.com/return-await-promise-javascript/\n","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"tty\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { app, BrowserWindow, ipcMain, dialog } from \"electron\";\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\nimport { trackMeta } from \"../interfaces/index\";\nimport { isDirectory, getMetaData } from \"../src/utils\";\n\nconst tracks = \"../data/tracks.json\";\n// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack\n// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on\n// whether you're running in development or production).\ndeclare const MAIN_WINDOW_WEBPACK_ENTRY: string;\ndeclare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;\n\n// Handle creating/removing shortcuts on Windows when installing/uninstalling.\nif (require(\"electron-squirrel-startup\")) {\n  // eslint-disable-line global-require\n  app.quit();\n}\n\nconst createWindow = (): void => {\n  // Create the browser window.\n  const mainWindow = new BrowserWindow({\n    height: 600,\n    width: 800,\n    webPreferences: {\n      contextIsolation: true,\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,\n    },\n  });\n\n  // and load the index.html of the app.\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\n\n  // Open the DevTools.\n  mainWindow.webContents.openDevTools();\n};\n\n// This method will be called when Electron has finished\n// initialization and is ready to create browser windows.\n// Some APIs can only be used after this event occurs.\napp.on(\"ready\", createWindow);\n\n// Quit when all windows are closed, except on macOS. There, it's common\n// for applications and their menu bar to stay active until the user quits\n// explicitly with Cmd + Q.\napp.on(\"window-all-closed\", () => {\n  if (process.platform !== \"darwin\") {\n    app.quit();\n  }\n});\n\napp.on(\"activate\", () => {\n  // On OS X it's common to re-create a window in the app when the\n  // dock icon is clicked and there are no other windows open.\n  if (BrowserWindow.getAllWindows().length === 0) {\n    createWindow();\n  }\n});\n\n// In this file you can include the rest of your app's specific main process\n// code. You can also put them in separate files and import them here.\nipcMain.handle(\"upload-files\", async (event, args) => {\n  // lets give them the dialog to choose a folder\n  const dialogButton = await dialog.showOpenDialog({\n    properties: [\"openDirectory\", \"createDirectory\", \"openFile\"],\n  });\n\n  // user selected cancel button to show selection process\n  if (dialogButton.canceled) return;\n\n  // I should be looking for an array. here is my options\n  const selectedPath: string[] | undefined = dialogButton?.filePaths;\n\n  // Is it a Directory | File?\n  if (selectedPath && isDirectory(selectedPath)) {\n    // filesPath will returns either string | string[]\n    // !!!!!!!!!!NEED TO PREPARE FOR string[] only takes string!!!!!!!\n    const [folderPath] = selectedPath;\n    const audioData = await getMetaData(folderPath);\n    return audioData;\n  }\n  // If files exist? how many?\n});\n\n// https://stackoverflow.com/questions/43455911/using-es6-spread-to-concat-multiple-arrays\n// https://stackoverflow.com/questions/15630770/node-js-check-if-path-is-file-or-directory\n"],"names":[],"sourceRoot":""}